// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/PokeForum/PokeForum/ent/blacklist"
	"github.com/PokeForum/PokeForum/ent/category"
	"github.com/PokeForum/PokeForum/ent/categorymoderator"
	"github.com/PokeForum/PokeForum/ent/comment"
	"github.com/PokeForum/PokeForum/ent/commentaction"
	"github.com/PokeForum/PokeForum/ent/oauthprovider"
	"github.com/PokeForum/PokeForum/ent/post"
	"github.com/PokeForum/PokeForum/ent/postaction"
	"github.com/PokeForum/PokeForum/ent/predicate"
	"github.com/PokeForum/PokeForum/ent/settings"
	"github.com/PokeForum/PokeForum/ent/user"
	"github.com/PokeForum/PokeForum/ent/userbalancelog"
	"github.com/PokeForum/PokeForum/ent/userloginlog"
	"github.com/PokeForum/PokeForum/ent/useroauth"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBlacklist         = "Blacklist"
	TypeCategory          = "Category"
	TypeCategoryModerator = "CategoryModerator"
	TypeComment           = "Comment"
	TypeCommentAction     = "CommentAction"
	TypeOAuthProvider     = "OAuthProvider"
	TypePost              = "Post"
	TypePostAction        = "PostAction"
	TypeSettings          = "Settings"
	TypeUser              = "User"
	TypeUserBalanceLog    = "UserBalanceLog"
	TypeUserLoginLog      = "UserLoginLog"
	TypeUserOAuth         = "UserOAuth"
)

// BlacklistMutation represents an operation that mutates the Blacklist nodes in the graph.
type BlacklistMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	created_at         *time.Time
	updated_at         *time.Time
	user_id            *int
	adduser_id         *int
	blocked_user_id    *int
	addblocked_user_id *int
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*Blacklist, error)
	predicates         []predicate.Blacklist
}

var _ ent.Mutation = (*BlacklistMutation)(nil)

// blacklistOption allows management of the mutation configuration using functional options.
type blacklistOption func(*BlacklistMutation)

// newBlacklistMutation creates new mutation for the Blacklist entity.
func newBlacklistMutation(c config, op Op, opts ...blacklistOption) *BlacklistMutation {
	m := &BlacklistMutation{
		config:        c,
		op:            op,
		typ:           TypeBlacklist,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlacklistID sets the ID field of the mutation.
func withBlacklistID(id int) blacklistOption {
	return func(m *BlacklistMutation) {
		var (
			err   error
			once  sync.Once
			value *Blacklist
		)
		m.oldValue = func(ctx context.Context) (*Blacklist, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Blacklist.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlacklist sets the old Blacklist of the mutation.
func withBlacklist(node *Blacklist) blacklistOption {
	return func(m *BlacklistMutation) {
		m.oldValue = func(context.Context) (*Blacklist, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlacklistMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlacklistMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Blacklist entities.
func (m *BlacklistMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlacklistMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlacklistMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Blacklist.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BlacklistMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlacklistMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Blacklist entity.
// If the Blacklist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlacklistMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlacklistMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BlacklistMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BlacklistMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Blacklist entity.
// If the Blacklist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlacklistMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BlacklistMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *BlacklistMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *BlacklistMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Blacklist entity.
// If the Blacklist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlacklistMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *BlacklistMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *BlacklistMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *BlacklistMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetBlockedUserID sets the "blocked_user_id" field.
func (m *BlacklistMutation) SetBlockedUserID(i int) {
	m.blocked_user_id = &i
	m.addblocked_user_id = nil
}

// BlockedUserID returns the value of the "blocked_user_id" field in the mutation.
func (m *BlacklistMutation) BlockedUserID() (r int, exists bool) {
	v := m.blocked_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockedUserID returns the old "blocked_user_id" field's value of the Blacklist entity.
// If the Blacklist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlacklistMutation) OldBlockedUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlockedUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlockedUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockedUserID: %w", err)
	}
	return oldValue.BlockedUserID, nil
}

// AddBlockedUserID adds i to the "blocked_user_id" field.
func (m *BlacklistMutation) AddBlockedUserID(i int) {
	if m.addblocked_user_id != nil {
		*m.addblocked_user_id += i
	} else {
		m.addblocked_user_id = &i
	}
}

// AddedBlockedUserID returns the value that was added to the "blocked_user_id" field in this mutation.
func (m *BlacklistMutation) AddedBlockedUserID() (r int, exists bool) {
	v := m.addblocked_user_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetBlockedUserID resets all changes to the "blocked_user_id" field.
func (m *BlacklistMutation) ResetBlockedUserID() {
	m.blocked_user_id = nil
	m.addblocked_user_id = nil
}

// Where appends a list predicates to the BlacklistMutation builder.
func (m *BlacklistMutation) Where(ps ...predicate.Blacklist) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlacklistMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlacklistMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Blacklist, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlacklistMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlacklistMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Blacklist).
func (m *BlacklistMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlacklistMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, blacklist.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, blacklist.FieldUpdatedAt)
	}
	if m.user_id != nil {
		fields = append(fields, blacklist.FieldUserID)
	}
	if m.blocked_user_id != nil {
		fields = append(fields, blacklist.FieldBlockedUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlacklistMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blacklist.FieldCreatedAt:
		return m.CreatedAt()
	case blacklist.FieldUpdatedAt:
		return m.UpdatedAt()
	case blacklist.FieldUserID:
		return m.UserID()
	case blacklist.FieldBlockedUserID:
		return m.BlockedUserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlacklistMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blacklist.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case blacklist.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case blacklist.FieldUserID:
		return m.OldUserID(ctx)
	case blacklist.FieldBlockedUserID:
		return m.OldBlockedUserID(ctx)
	}
	return nil, fmt.Errorf("unknown Blacklist field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlacklistMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blacklist.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case blacklist.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case blacklist.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case blacklist.FieldBlockedUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockedUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Blacklist field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlacklistMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, blacklist.FieldUserID)
	}
	if m.addblocked_user_id != nil {
		fields = append(fields, blacklist.FieldBlockedUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlacklistMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case blacklist.FieldUserID:
		return m.AddedUserID()
	case blacklist.FieldBlockedUserID:
		return m.AddedBlockedUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlacklistMutation) AddField(name string, value ent.Value) error {
	switch name {
	case blacklist.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case blacklist.FieldBlockedUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBlockedUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Blacklist numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlacklistMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlacklistMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlacklistMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Blacklist nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlacklistMutation) ResetField(name string) error {
	switch name {
	case blacklist.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case blacklist.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case blacklist.FieldUserID:
		m.ResetUserID()
		return nil
	case blacklist.FieldBlockedUserID:
		m.ResetBlockedUserID()
		return nil
	}
	return fmt.Errorf("unknown Blacklist field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlacklistMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlacklistMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlacklistMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlacklistMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlacklistMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlacklistMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlacklistMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Blacklist unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlacklistMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Blacklist edge %s", name)
}

// CategoryMutation represents an operation that mutates the Category nodes in the graph.
type CategoryMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	name          *string
	slug          *string
	description   *string
	icon          *string
	weight        *int
	addweight     *int
	status        *category.Status
	announcement  *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Category, error)
	predicates    []predicate.Category
}

var _ ent.Mutation = (*CategoryMutation)(nil)

// categoryOption allows management of the mutation configuration using functional options.
type categoryOption func(*CategoryMutation)

// newCategoryMutation creates new mutation for the Category entity.
func newCategoryMutation(c config, op Op, opts ...categoryOption) *CategoryMutation {
	m := &CategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCategoryID sets the ID field of the mutation.
func withCategoryID(id int) categoryOption {
	return func(m *CategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Category
		)
		m.oldValue = func(ctx context.Context) (*Category, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Category.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCategory sets the old Category of the mutation.
func withCategory(node *Category) categoryOption {
	return func(m *CategoryMutation) {
		m.oldValue = func(context.Context) (*Category, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Category entities.
func (m *CategoryMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CategoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Category.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *CategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CategoryMutation) ResetName() {
	m.name = nil
}

// SetSlug sets the "slug" field.
func (m *CategoryMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *CategoryMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *CategoryMutation) ResetSlug() {
	m.slug = nil
}

// SetDescription sets the "description" field.
func (m *CategoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CategoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CategoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[category.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CategoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[category.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CategoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, category.FieldDescription)
}

// SetIcon sets the "icon" field.
func (m *CategoryMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *CategoryMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *CategoryMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[category.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *CategoryMutation) IconCleared() bool {
	_, ok := m.clearedFields[category.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *CategoryMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, category.FieldIcon)
}

// SetWeight sets the "weight" field.
func (m *CategoryMutation) SetWeight(i int) {
	m.weight = &i
	m.addweight = nil
}

// Weight returns the value of the "weight" field in the mutation.
func (m *CategoryMutation) Weight() (r int, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old "weight" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldWeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// AddWeight adds i to the "weight" field.
func (m *CategoryMutation) AddWeight(i int) {
	if m.addweight != nil {
		*m.addweight += i
	} else {
		m.addweight = &i
	}
}

// AddedWeight returns the value that was added to the "weight" field in this mutation.
func (m *CategoryMutation) AddedWeight() (r int, exists bool) {
	v := m.addweight
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeight resets all changes to the "weight" field.
func (m *CategoryMutation) ResetWeight() {
	m.weight = nil
	m.addweight = nil
}

// SetStatus sets the "status" field.
func (m *CategoryMutation) SetStatus(c category.Status) {
	m.status = &c
}

// Status returns the value of the "status" field in the mutation.
func (m *CategoryMutation) Status() (r category.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldStatus(ctx context.Context) (v category.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CategoryMutation) ResetStatus() {
	m.status = nil
}

// SetAnnouncement sets the "announcement" field.
func (m *CategoryMutation) SetAnnouncement(s string) {
	m.announcement = &s
}

// Announcement returns the value of the "announcement" field in the mutation.
func (m *CategoryMutation) Announcement() (r string, exists bool) {
	v := m.announcement
	if v == nil {
		return
	}
	return *v, true
}

// OldAnnouncement returns the old "announcement" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldAnnouncement(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnnouncement is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnnouncement requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnnouncement: %w", err)
	}
	return oldValue.Announcement, nil
}

// ClearAnnouncement clears the value of the "announcement" field.
func (m *CategoryMutation) ClearAnnouncement() {
	m.announcement = nil
	m.clearedFields[category.FieldAnnouncement] = struct{}{}
}

// AnnouncementCleared returns if the "announcement" field was cleared in this mutation.
func (m *CategoryMutation) AnnouncementCleared() bool {
	_, ok := m.clearedFields[category.FieldAnnouncement]
	return ok
}

// ResetAnnouncement resets all changes to the "announcement" field.
func (m *CategoryMutation) ResetAnnouncement() {
	m.announcement = nil
	delete(m.clearedFields, category.FieldAnnouncement)
}

// Where appends a list predicates to the CategoryMutation builder.
func (m *CategoryMutation) Where(ps ...predicate.Category) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Category, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Category).
func (m *CategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CategoryMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, category.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, category.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, category.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, category.FieldSlug)
	}
	if m.description != nil {
		fields = append(fields, category.FieldDescription)
	}
	if m.icon != nil {
		fields = append(fields, category.FieldIcon)
	}
	if m.weight != nil {
		fields = append(fields, category.FieldWeight)
	}
	if m.status != nil {
		fields = append(fields, category.FieldStatus)
	}
	if m.announcement != nil {
		fields = append(fields, category.FieldAnnouncement)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case category.FieldCreatedAt:
		return m.CreatedAt()
	case category.FieldUpdatedAt:
		return m.UpdatedAt()
	case category.FieldName:
		return m.Name()
	case category.FieldSlug:
		return m.Slug()
	case category.FieldDescription:
		return m.Description()
	case category.FieldIcon:
		return m.Icon()
	case category.FieldWeight:
		return m.Weight()
	case category.FieldStatus:
		return m.Status()
	case category.FieldAnnouncement:
		return m.Announcement()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case category.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case category.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case category.FieldName:
		return m.OldName(ctx)
	case category.FieldSlug:
		return m.OldSlug(ctx)
	case category.FieldDescription:
		return m.OldDescription(ctx)
	case category.FieldIcon:
		return m.OldIcon(ctx)
	case category.FieldWeight:
		return m.OldWeight(ctx)
	case category.FieldStatus:
		return m.OldStatus(ctx)
	case category.FieldAnnouncement:
		return m.OldAnnouncement(ctx)
	}
	return nil, fmt.Errorf("unknown Category field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case category.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case category.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case category.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case category.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case category.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case category.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case category.FieldWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	case category.FieldStatus:
		v, ok := value.(category.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case category.FieldAnnouncement:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnnouncement(v)
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CategoryMutation) AddedFields() []string {
	var fields []string
	if m.addweight != nil {
		fields = append(fields, category.FieldWeight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case category.FieldWeight:
		return m.AddedWeight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case category.FieldWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeight(v)
		return nil
	}
	return fmt.Errorf("unknown Category numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(category.FieldDescription) {
		fields = append(fields, category.FieldDescription)
	}
	if m.FieldCleared(category.FieldIcon) {
		fields = append(fields, category.FieldIcon)
	}
	if m.FieldCleared(category.FieldAnnouncement) {
		fields = append(fields, category.FieldAnnouncement)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CategoryMutation) ClearField(name string) error {
	switch name {
	case category.FieldDescription:
		m.ClearDescription()
		return nil
	case category.FieldIcon:
		m.ClearIcon()
		return nil
	case category.FieldAnnouncement:
		m.ClearAnnouncement()
		return nil
	}
	return fmt.Errorf("unknown Category nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CategoryMutation) ResetField(name string) error {
	switch name {
	case category.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case category.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case category.FieldName:
		m.ResetName()
		return nil
	case category.FieldSlug:
		m.ResetSlug()
		return nil
	case category.FieldDescription:
		m.ResetDescription()
		return nil
	case category.FieldIcon:
		m.ResetIcon()
		return nil
	case category.FieldWeight:
		m.ResetWeight()
		return nil
	case category.FieldStatus:
		m.ResetStatus()
		return nil
	case category.FieldAnnouncement:
		m.ResetAnnouncement()
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CategoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CategoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CategoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CategoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Category unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CategoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Category edge %s", name)
}

// CategoryModeratorMutation represents an operation that mutates the CategoryModerator nodes in the graph.
type CategoryModeratorMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	category_id    *int
	addcategory_id *int
	user_id        *int
	adduser_id     *int
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*CategoryModerator, error)
	predicates     []predicate.CategoryModerator
}

var _ ent.Mutation = (*CategoryModeratorMutation)(nil)

// categorymoderatorOption allows management of the mutation configuration using functional options.
type categorymoderatorOption func(*CategoryModeratorMutation)

// newCategoryModeratorMutation creates new mutation for the CategoryModerator entity.
func newCategoryModeratorMutation(c config, op Op, opts ...categorymoderatorOption) *CategoryModeratorMutation {
	m := &CategoryModeratorMutation{
		config:        c,
		op:            op,
		typ:           TypeCategoryModerator,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCategoryModeratorID sets the ID field of the mutation.
func withCategoryModeratorID(id int) categorymoderatorOption {
	return func(m *CategoryModeratorMutation) {
		var (
			err   error
			once  sync.Once
			value *CategoryModerator
		)
		m.oldValue = func(ctx context.Context) (*CategoryModerator, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CategoryModerator.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCategoryModerator sets the old CategoryModerator of the mutation.
func withCategoryModerator(node *CategoryModerator) categorymoderatorOption {
	return func(m *CategoryModeratorMutation) {
		m.oldValue = func(context.Context) (*CategoryModerator, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CategoryModeratorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CategoryModeratorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CategoryModerator entities.
func (m *CategoryModeratorMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CategoryModeratorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CategoryModeratorMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CategoryModerator.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CategoryModeratorMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CategoryModeratorMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CategoryModerator entity.
// If the CategoryModerator object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryModeratorMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CategoryModeratorMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CategoryModeratorMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CategoryModeratorMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CategoryModerator entity.
// If the CategoryModerator object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryModeratorMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CategoryModeratorMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCategoryID sets the "category_id" field.
func (m *CategoryModeratorMutation) SetCategoryID(i int) {
	m.category_id = &i
	m.addcategory_id = nil
}

// CategoryID returns the value of the "category_id" field in the mutation.
func (m *CategoryModeratorMutation) CategoryID() (r int, exists bool) {
	v := m.category_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "category_id" field's value of the CategoryModerator entity.
// If the CategoryModerator object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryModeratorMutation) OldCategoryID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// AddCategoryID adds i to the "category_id" field.
func (m *CategoryModeratorMutation) AddCategoryID(i int) {
	if m.addcategory_id != nil {
		*m.addcategory_id += i
	} else {
		m.addcategory_id = &i
	}
}

// AddedCategoryID returns the value that was added to the "category_id" field in this mutation.
func (m *CategoryModeratorMutation) AddedCategoryID() (r int, exists bool) {
	v := m.addcategory_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCategoryID resets all changes to the "category_id" field.
func (m *CategoryModeratorMutation) ResetCategoryID() {
	m.category_id = nil
	m.addcategory_id = nil
}

// SetUserID sets the "user_id" field.
func (m *CategoryModeratorMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CategoryModeratorMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the CategoryModerator entity.
// If the CategoryModerator object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryModeratorMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *CategoryModeratorMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *CategoryModeratorMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CategoryModeratorMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// Where appends a list predicates to the CategoryModeratorMutation builder.
func (m *CategoryModeratorMutation) Where(ps ...predicate.CategoryModerator) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CategoryModeratorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CategoryModeratorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CategoryModerator, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CategoryModeratorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CategoryModeratorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CategoryModerator).
func (m *CategoryModeratorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CategoryModeratorMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, categorymoderator.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, categorymoderator.FieldUpdatedAt)
	}
	if m.category_id != nil {
		fields = append(fields, categorymoderator.FieldCategoryID)
	}
	if m.user_id != nil {
		fields = append(fields, categorymoderator.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CategoryModeratorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case categorymoderator.FieldCreatedAt:
		return m.CreatedAt()
	case categorymoderator.FieldUpdatedAt:
		return m.UpdatedAt()
	case categorymoderator.FieldCategoryID:
		return m.CategoryID()
	case categorymoderator.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CategoryModeratorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case categorymoderator.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case categorymoderator.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case categorymoderator.FieldCategoryID:
		return m.OldCategoryID(ctx)
	case categorymoderator.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown CategoryModerator field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryModeratorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case categorymoderator.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case categorymoderator.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case categorymoderator.FieldCategoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	case categorymoderator.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown CategoryModerator field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CategoryModeratorMutation) AddedFields() []string {
	var fields []string
	if m.addcategory_id != nil {
		fields = append(fields, categorymoderator.FieldCategoryID)
	}
	if m.adduser_id != nil {
		fields = append(fields, categorymoderator.FieldUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CategoryModeratorMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case categorymoderator.FieldCategoryID:
		return m.AddedCategoryID()
	case categorymoderator.FieldUserID:
		return m.AddedUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryModeratorMutation) AddField(name string, value ent.Value) error {
	switch name {
	case categorymoderator.FieldCategoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCategoryID(v)
		return nil
	case categorymoderator.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	}
	return fmt.Errorf("unknown CategoryModerator numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CategoryModeratorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CategoryModeratorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CategoryModeratorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CategoryModerator nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CategoryModeratorMutation) ResetField(name string) error {
	switch name {
	case categorymoderator.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case categorymoderator.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case categorymoderator.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	case categorymoderator.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown CategoryModerator field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CategoryModeratorMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CategoryModeratorMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CategoryModeratorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CategoryModeratorMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CategoryModeratorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CategoryModeratorMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CategoryModeratorMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CategoryModerator unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CategoryModeratorMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CategoryModerator edge %s", name)
}

// CommentMutation represents an operation that mutates the Comment nodes in the graph.
type CommentMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	created_at          *time.Time
	updated_at          *time.Time
	post_id             *int
	addpost_id          *int
	user_id             *int
	adduser_id          *int
	parent_id           *int
	addparent_id        *int
	reply_to_user_id    *int
	addreply_to_user_id *int
	content             *string
	like_count          *int
	addlike_count       *int
	dislike_count       *int
	adddislike_count    *int
	is_selected         *bool
	is_pinned           *bool
	commenter_ip        *string
	device_info         *string
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*Comment, error)
	predicates          []predicate.Comment
}

var _ ent.Mutation = (*CommentMutation)(nil)

// commentOption allows management of the mutation configuration using functional options.
type commentOption func(*CommentMutation)

// newCommentMutation creates new mutation for the Comment entity.
func newCommentMutation(c config, op Op, opts ...commentOption) *CommentMutation {
	m := &CommentMutation{
		config:        c,
		op:            op,
		typ:           TypeComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommentID sets the ID field of the mutation.
func withCommentID(id int) commentOption {
	return func(m *CommentMutation) {
		var (
			err   error
			once  sync.Once
			value *Comment
		)
		m.oldValue = func(ctx context.Context) (*Comment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Comment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withComment sets the old Comment of the mutation.
func withComment(node *Comment) commentOption {
	return func(m *CommentMutation) {
		m.oldValue = func(context.Context) (*Comment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Comment entities.
func (m *CommentMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Comment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CommentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CommentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CommentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CommentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CommentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CommentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetPostID sets the "post_id" field.
func (m *CommentMutation) SetPostID(i int) {
	m.post_id = &i
	m.addpost_id = nil
}

// PostID returns the value of the "post_id" field in the mutation.
func (m *CommentMutation) PostID() (r int, exists bool) {
	v := m.post_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPostID returns the old "post_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldPostID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostID: %w", err)
	}
	return oldValue.PostID, nil
}

// AddPostID adds i to the "post_id" field.
func (m *CommentMutation) AddPostID(i int) {
	if m.addpost_id != nil {
		*m.addpost_id += i
	} else {
		m.addpost_id = &i
	}
}

// AddedPostID returns the value that was added to the "post_id" field in this mutation.
func (m *CommentMutation) AddedPostID() (r int, exists bool) {
	v := m.addpost_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetPostID resets all changes to the "post_id" field.
func (m *CommentMutation) ResetPostID() {
	m.post_id = nil
	m.addpost_id = nil
}

// SetUserID sets the "user_id" field.
func (m *CommentMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CommentMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *CommentMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *CommentMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CommentMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetParentID sets the "parent_id" field.
func (m *CommentMutation) SetParentID(i int) {
	m.parent_id = &i
	m.addparent_id = nil
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *CommentMutation) ParentID() (r int, exists bool) {
	v := m.parent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldParentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// AddParentID adds i to the "parent_id" field.
func (m *CommentMutation) AddParentID(i int) {
	if m.addparent_id != nil {
		*m.addparent_id += i
	} else {
		m.addparent_id = &i
	}
}

// AddedParentID returns the value that was added to the "parent_id" field in this mutation.
func (m *CommentMutation) AddedParentID() (r int, exists bool) {
	v := m.addparent_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearParentID clears the value of the "parent_id" field.
func (m *CommentMutation) ClearParentID() {
	m.parent_id = nil
	m.addparent_id = nil
	m.clearedFields[comment.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *CommentMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[comment.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *CommentMutation) ResetParentID() {
	m.parent_id = nil
	m.addparent_id = nil
	delete(m.clearedFields, comment.FieldParentID)
}

// SetReplyToUserID sets the "reply_to_user_id" field.
func (m *CommentMutation) SetReplyToUserID(i int) {
	m.reply_to_user_id = &i
	m.addreply_to_user_id = nil
}

// ReplyToUserID returns the value of the "reply_to_user_id" field in the mutation.
func (m *CommentMutation) ReplyToUserID() (r int, exists bool) {
	v := m.reply_to_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReplyToUserID returns the old "reply_to_user_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldReplyToUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReplyToUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReplyToUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReplyToUserID: %w", err)
	}
	return oldValue.ReplyToUserID, nil
}

// AddReplyToUserID adds i to the "reply_to_user_id" field.
func (m *CommentMutation) AddReplyToUserID(i int) {
	if m.addreply_to_user_id != nil {
		*m.addreply_to_user_id += i
	} else {
		m.addreply_to_user_id = &i
	}
}

// AddedReplyToUserID returns the value that was added to the "reply_to_user_id" field in this mutation.
func (m *CommentMutation) AddedReplyToUserID() (r int, exists bool) {
	v := m.addreply_to_user_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearReplyToUserID clears the value of the "reply_to_user_id" field.
func (m *CommentMutation) ClearReplyToUserID() {
	m.reply_to_user_id = nil
	m.addreply_to_user_id = nil
	m.clearedFields[comment.FieldReplyToUserID] = struct{}{}
}

// ReplyToUserIDCleared returns if the "reply_to_user_id" field was cleared in this mutation.
func (m *CommentMutation) ReplyToUserIDCleared() bool {
	_, ok := m.clearedFields[comment.FieldReplyToUserID]
	return ok
}

// ResetReplyToUserID resets all changes to the "reply_to_user_id" field.
func (m *CommentMutation) ResetReplyToUserID() {
	m.reply_to_user_id = nil
	m.addreply_to_user_id = nil
	delete(m.clearedFields, comment.FieldReplyToUserID)
}

// SetContent sets the "content" field.
func (m *CommentMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *CommentMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *CommentMutation) ResetContent() {
	m.content = nil
}

// SetLikeCount sets the "like_count" field.
func (m *CommentMutation) SetLikeCount(i int) {
	m.like_count = &i
	m.addlike_count = nil
}

// LikeCount returns the value of the "like_count" field in the mutation.
func (m *CommentMutation) LikeCount() (r int, exists bool) {
	v := m.like_count
	if v == nil {
		return
	}
	return *v, true
}

// OldLikeCount returns the old "like_count" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldLikeCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLikeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLikeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLikeCount: %w", err)
	}
	return oldValue.LikeCount, nil
}

// AddLikeCount adds i to the "like_count" field.
func (m *CommentMutation) AddLikeCount(i int) {
	if m.addlike_count != nil {
		*m.addlike_count += i
	} else {
		m.addlike_count = &i
	}
}

// AddedLikeCount returns the value that was added to the "like_count" field in this mutation.
func (m *CommentMutation) AddedLikeCount() (r int, exists bool) {
	v := m.addlike_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetLikeCount resets all changes to the "like_count" field.
func (m *CommentMutation) ResetLikeCount() {
	m.like_count = nil
	m.addlike_count = nil
}

// SetDislikeCount sets the "dislike_count" field.
func (m *CommentMutation) SetDislikeCount(i int) {
	m.dislike_count = &i
	m.adddislike_count = nil
}

// DislikeCount returns the value of the "dislike_count" field in the mutation.
func (m *CommentMutation) DislikeCount() (r int, exists bool) {
	v := m.dislike_count
	if v == nil {
		return
	}
	return *v, true
}

// OldDislikeCount returns the old "dislike_count" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldDislikeCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDislikeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDislikeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDislikeCount: %w", err)
	}
	return oldValue.DislikeCount, nil
}

// AddDislikeCount adds i to the "dislike_count" field.
func (m *CommentMutation) AddDislikeCount(i int) {
	if m.adddislike_count != nil {
		*m.adddislike_count += i
	} else {
		m.adddislike_count = &i
	}
}

// AddedDislikeCount returns the value that was added to the "dislike_count" field in this mutation.
func (m *CommentMutation) AddedDislikeCount() (r int, exists bool) {
	v := m.adddislike_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetDislikeCount resets all changes to the "dislike_count" field.
func (m *CommentMutation) ResetDislikeCount() {
	m.dislike_count = nil
	m.adddislike_count = nil
}

// SetIsSelected sets the "is_selected" field.
func (m *CommentMutation) SetIsSelected(b bool) {
	m.is_selected = &b
}

// IsSelected returns the value of the "is_selected" field in the mutation.
func (m *CommentMutation) IsSelected() (r bool, exists bool) {
	v := m.is_selected
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSelected returns the old "is_selected" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldIsSelected(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsSelected is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsSelected requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSelected: %w", err)
	}
	return oldValue.IsSelected, nil
}

// ResetIsSelected resets all changes to the "is_selected" field.
func (m *CommentMutation) ResetIsSelected() {
	m.is_selected = nil
}

// SetIsPinned sets the "is_pinned" field.
func (m *CommentMutation) SetIsPinned(b bool) {
	m.is_pinned = &b
}

// IsPinned returns the value of the "is_pinned" field in the mutation.
func (m *CommentMutation) IsPinned() (r bool, exists bool) {
	v := m.is_pinned
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPinned returns the old "is_pinned" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldIsPinned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPinned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPinned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPinned: %w", err)
	}
	return oldValue.IsPinned, nil
}

// ResetIsPinned resets all changes to the "is_pinned" field.
func (m *CommentMutation) ResetIsPinned() {
	m.is_pinned = nil
}

// SetCommenterIP sets the "commenter_ip" field.
func (m *CommentMutation) SetCommenterIP(s string) {
	m.commenter_ip = &s
}

// CommenterIP returns the value of the "commenter_ip" field in the mutation.
func (m *CommentMutation) CommenterIP() (r string, exists bool) {
	v := m.commenter_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldCommenterIP returns the old "commenter_ip" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldCommenterIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommenterIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommenterIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommenterIP: %w", err)
	}
	return oldValue.CommenterIP, nil
}

// ClearCommenterIP clears the value of the "commenter_ip" field.
func (m *CommentMutation) ClearCommenterIP() {
	m.commenter_ip = nil
	m.clearedFields[comment.FieldCommenterIP] = struct{}{}
}

// CommenterIPCleared returns if the "commenter_ip" field was cleared in this mutation.
func (m *CommentMutation) CommenterIPCleared() bool {
	_, ok := m.clearedFields[comment.FieldCommenterIP]
	return ok
}

// ResetCommenterIP resets all changes to the "commenter_ip" field.
func (m *CommentMutation) ResetCommenterIP() {
	m.commenter_ip = nil
	delete(m.clearedFields, comment.FieldCommenterIP)
}

// SetDeviceInfo sets the "device_info" field.
func (m *CommentMutation) SetDeviceInfo(s string) {
	m.device_info = &s
}

// DeviceInfo returns the value of the "device_info" field in the mutation.
func (m *CommentMutation) DeviceInfo() (r string, exists bool) {
	v := m.device_info
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceInfo returns the old "device_info" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldDeviceInfo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceInfo: %w", err)
	}
	return oldValue.DeviceInfo, nil
}

// ClearDeviceInfo clears the value of the "device_info" field.
func (m *CommentMutation) ClearDeviceInfo() {
	m.device_info = nil
	m.clearedFields[comment.FieldDeviceInfo] = struct{}{}
}

// DeviceInfoCleared returns if the "device_info" field was cleared in this mutation.
func (m *CommentMutation) DeviceInfoCleared() bool {
	_, ok := m.clearedFields[comment.FieldDeviceInfo]
	return ok
}

// ResetDeviceInfo resets all changes to the "device_info" field.
func (m *CommentMutation) ResetDeviceInfo() {
	m.device_info = nil
	delete(m.clearedFields, comment.FieldDeviceInfo)
}

// Where appends a list predicates to the CommentMutation builder.
func (m *CommentMutation) Where(ps ...predicate.Comment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CommentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CommentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Comment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CommentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CommentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Comment).
func (m *CommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommentMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, comment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, comment.FieldUpdatedAt)
	}
	if m.post_id != nil {
		fields = append(fields, comment.FieldPostID)
	}
	if m.user_id != nil {
		fields = append(fields, comment.FieldUserID)
	}
	if m.parent_id != nil {
		fields = append(fields, comment.FieldParentID)
	}
	if m.reply_to_user_id != nil {
		fields = append(fields, comment.FieldReplyToUserID)
	}
	if m.content != nil {
		fields = append(fields, comment.FieldContent)
	}
	if m.like_count != nil {
		fields = append(fields, comment.FieldLikeCount)
	}
	if m.dislike_count != nil {
		fields = append(fields, comment.FieldDislikeCount)
	}
	if m.is_selected != nil {
		fields = append(fields, comment.FieldIsSelected)
	}
	if m.is_pinned != nil {
		fields = append(fields, comment.FieldIsPinned)
	}
	if m.commenter_ip != nil {
		fields = append(fields, comment.FieldCommenterIP)
	}
	if m.device_info != nil {
		fields = append(fields, comment.FieldDeviceInfo)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case comment.FieldCreatedAt:
		return m.CreatedAt()
	case comment.FieldUpdatedAt:
		return m.UpdatedAt()
	case comment.FieldPostID:
		return m.PostID()
	case comment.FieldUserID:
		return m.UserID()
	case comment.FieldParentID:
		return m.ParentID()
	case comment.FieldReplyToUserID:
		return m.ReplyToUserID()
	case comment.FieldContent:
		return m.Content()
	case comment.FieldLikeCount:
		return m.LikeCount()
	case comment.FieldDislikeCount:
		return m.DislikeCount()
	case comment.FieldIsSelected:
		return m.IsSelected()
	case comment.FieldIsPinned:
		return m.IsPinned()
	case comment.FieldCommenterIP:
		return m.CommenterIP()
	case comment.FieldDeviceInfo:
		return m.DeviceInfo()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case comment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case comment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case comment.FieldPostID:
		return m.OldPostID(ctx)
	case comment.FieldUserID:
		return m.OldUserID(ctx)
	case comment.FieldParentID:
		return m.OldParentID(ctx)
	case comment.FieldReplyToUserID:
		return m.OldReplyToUserID(ctx)
	case comment.FieldContent:
		return m.OldContent(ctx)
	case comment.FieldLikeCount:
		return m.OldLikeCount(ctx)
	case comment.FieldDislikeCount:
		return m.OldDislikeCount(ctx)
	case comment.FieldIsSelected:
		return m.OldIsSelected(ctx)
	case comment.FieldIsPinned:
		return m.OldIsPinned(ctx)
	case comment.FieldCommenterIP:
		return m.OldCommenterIP(ctx)
	case comment.FieldDeviceInfo:
		return m.OldDeviceInfo(ctx)
	}
	return nil, fmt.Errorf("unknown Comment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case comment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case comment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case comment.FieldPostID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostID(v)
		return nil
	case comment.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case comment.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case comment.FieldReplyToUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReplyToUserID(v)
		return nil
	case comment.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case comment.FieldLikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikeCount(v)
		return nil
	case comment.FieldDislikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDislikeCount(v)
		return nil
	case comment.FieldIsSelected:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSelected(v)
		return nil
	case comment.FieldIsPinned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPinned(v)
		return nil
	case comment.FieldCommenterIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommenterIP(v)
		return nil
	case comment.FieldDeviceInfo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceInfo(v)
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommentMutation) AddedFields() []string {
	var fields []string
	if m.addpost_id != nil {
		fields = append(fields, comment.FieldPostID)
	}
	if m.adduser_id != nil {
		fields = append(fields, comment.FieldUserID)
	}
	if m.addparent_id != nil {
		fields = append(fields, comment.FieldParentID)
	}
	if m.addreply_to_user_id != nil {
		fields = append(fields, comment.FieldReplyToUserID)
	}
	if m.addlike_count != nil {
		fields = append(fields, comment.FieldLikeCount)
	}
	if m.adddislike_count != nil {
		fields = append(fields, comment.FieldDislikeCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case comment.FieldPostID:
		return m.AddedPostID()
	case comment.FieldUserID:
		return m.AddedUserID()
	case comment.FieldParentID:
		return m.AddedParentID()
	case comment.FieldReplyToUserID:
		return m.AddedReplyToUserID()
	case comment.FieldLikeCount:
		return m.AddedLikeCount()
	case comment.FieldDislikeCount:
		return m.AddedDislikeCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case comment.FieldPostID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPostID(v)
		return nil
	case comment.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case comment.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddParentID(v)
		return nil
	case comment.FieldReplyToUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReplyToUserID(v)
		return nil
	case comment.FieldLikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLikeCount(v)
		return nil
	case comment.FieldDislikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDislikeCount(v)
		return nil
	}
	return fmt.Errorf("unknown Comment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(comment.FieldParentID) {
		fields = append(fields, comment.FieldParentID)
	}
	if m.FieldCleared(comment.FieldReplyToUserID) {
		fields = append(fields, comment.FieldReplyToUserID)
	}
	if m.FieldCleared(comment.FieldCommenterIP) {
		fields = append(fields, comment.FieldCommenterIP)
	}
	if m.FieldCleared(comment.FieldDeviceInfo) {
		fields = append(fields, comment.FieldDeviceInfo)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommentMutation) ClearField(name string) error {
	switch name {
	case comment.FieldParentID:
		m.ClearParentID()
		return nil
	case comment.FieldReplyToUserID:
		m.ClearReplyToUserID()
		return nil
	case comment.FieldCommenterIP:
		m.ClearCommenterIP()
		return nil
	case comment.FieldDeviceInfo:
		m.ClearDeviceInfo()
		return nil
	}
	return fmt.Errorf("unknown Comment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommentMutation) ResetField(name string) error {
	switch name {
	case comment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case comment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case comment.FieldPostID:
		m.ResetPostID()
		return nil
	case comment.FieldUserID:
		m.ResetUserID()
		return nil
	case comment.FieldParentID:
		m.ResetParentID()
		return nil
	case comment.FieldReplyToUserID:
		m.ResetReplyToUserID()
		return nil
	case comment.FieldContent:
		m.ResetContent()
		return nil
	case comment.FieldLikeCount:
		m.ResetLikeCount()
		return nil
	case comment.FieldDislikeCount:
		m.ResetDislikeCount()
		return nil
	case comment.FieldIsSelected:
		m.ResetIsSelected()
		return nil
	case comment.FieldIsPinned:
		m.ResetIsPinned()
		return nil
	case comment.FieldCommenterIP:
		m.ResetCommenterIP()
		return nil
	case comment.FieldDeviceInfo:
		m.ResetDeviceInfo()
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommentMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommentMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommentMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Comment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommentMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Comment edge %s", name)
}

// CommentActionMutation represents an operation that mutates the CommentAction nodes in the graph.
type CommentActionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	user_id       *int
	adduser_id    *int
	comment_id    *int
	addcomment_id *int
	action_type   *commentaction.ActionType
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CommentAction, error)
	predicates    []predicate.CommentAction
}

var _ ent.Mutation = (*CommentActionMutation)(nil)

// commentactionOption allows management of the mutation configuration using functional options.
type commentactionOption func(*CommentActionMutation)

// newCommentActionMutation creates new mutation for the CommentAction entity.
func newCommentActionMutation(c config, op Op, opts ...commentactionOption) *CommentActionMutation {
	m := &CommentActionMutation{
		config:        c,
		op:            op,
		typ:           TypeCommentAction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommentActionID sets the ID field of the mutation.
func withCommentActionID(id int) commentactionOption {
	return func(m *CommentActionMutation) {
		var (
			err   error
			once  sync.Once
			value *CommentAction
		)
		m.oldValue = func(ctx context.Context) (*CommentAction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CommentAction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCommentAction sets the old CommentAction of the mutation.
func withCommentAction(node *CommentAction) commentactionOption {
	return func(m *CommentActionMutation) {
		m.oldValue = func(context.Context) (*CommentAction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommentActionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommentActionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CommentAction entities.
func (m *CommentActionMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommentActionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommentActionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CommentAction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CommentActionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CommentActionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CommentAction entity.
// If the CommentAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentActionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CommentActionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CommentActionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CommentActionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CommentAction entity.
// If the CommentAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentActionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CommentActionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *CommentActionMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CommentActionMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the CommentAction entity.
// If the CommentAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentActionMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *CommentActionMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *CommentActionMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CommentActionMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetCommentID sets the "comment_id" field.
func (m *CommentActionMutation) SetCommentID(i int) {
	m.comment_id = &i
	m.addcomment_id = nil
}

// CommentID returns the value of the "comment_id" field in the mutation.
func (m *CommentActionMutation) CommentID() (r int, exists bool) {
	v := m.comment_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCommentID returns the old "comment_id" field's value of the CommentAction entity.
// If the CommentAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentActionMutation) OldCommentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommentID: %w", err)
	}
	return oldValue.CommentID, nil
}

// AddCommentID adds i to the "comment_id" field.
func (m *CommentActionMutation) AddCommentID(i int) {
	if m.addcomment_id != nil {
		*m.addcomment_id += i
	} else {
		m.addcomment_id = &i
	}
}

// AddedCommentID returns the value that was added to the "comment_id" field in this mutation.
func (m *CommentActionMutation) AddedCommentID() (r int, exists bool) {
	v := m.addcomment_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCommentID resets all changes to the "comment_id" field.
func (m *CommentActionMutation) ResetCommentID() {
	m.comment_id = nil
	m.addcomment_id = nil
}

// SetActionType sets the "action_type" field.
func (m *CommentActionMutation) SetActionType(ct commentaction.ActionType) {
	m.action_type = &ct
}

// ActionType returns the value of the "action_type" field in the mutation.
func (m *CommentActionMutation) ActionType() (r commentaction.ActionType, exists bool) {
	v := m.action_type
	if v == nil {
		return
	}
	return *v, true
}

// OldActionType returns the old "action_type" field's value of the CommentAction entity.
// If the CommentAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentActionMutation) OldActionType(ctx context.Context) (v commentaction.ActionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionType: %w", err)
	}
	return oldValue.ActionType, nil
}

// ResetActionType resets all changes to the "action_type" field.
func (m *CommentActionMutation) ResetActionType() {
	m.action_type = nil
}

// Where appends a list predicates to the CommentActionMutation builder.
func (m *CommentActionMutation) Where(ps ...predicate.CommentAction) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CommentActionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CommentActionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CommentAction, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CommentActionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CommentActionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CommentAction).
func (m *CommentActionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommentActionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, commentaction.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, commentaction.FieldUpdatedAt)
	}
	if m.user_id != nil {
		fields = append(fields, commentaction.FieldUserID)
	}
	if m.comment_id != nil {
		fields = append(fields, commentaction.FieldCommentID)
	}
	if m.action_type != nil {
		fields = append(fields, commentaction.FieldActionType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommentActionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case commentaction.FieldCreatedAt:
		return m.CreatedAt()
	case commentaction.FieldUpdatedAt:
		return m.UpdatedAt()
	case commentaction.FieldUserID:
		return m.UserID()
	case commentaction.FieldCommentID:
		return m.CommentID()
	case commentaction.FieldActionType:
		return m.ActionType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommentActionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case commentaction.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case commentaction.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case commentaction.FieldUserID:
		return m.OldUserID(ctx)
	case commentaction.FieldCommentID:
		return m.OldCommentID(ctx)
	case commentaction.FieldActionType:
		return m.OldActionType(ctx)
	}
	return nil, fmt.Errorf("unknown CommentAction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentActionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case commentaction.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case commentaction.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case commentaction.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case commentaction.FieldCommentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommentID(v)
		return nil
	case commentaction.FieldActionType:
		v, ok := value.(commentaction.ActionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionType(v)
		return nil
	}
	return fmt.Errorf("unknown CommentAction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommentActionMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, commentaction.FieldUserID)
	}
	if m.addcomment_id != nil {
		fields = append(fields, commentaction.FieldCommentID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommentActionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case commentaction.FieldUserID:
		return m.AddedUserID()
	case commentaction.FieldCommentID:
		return m.AddedCommentID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentActionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case commentaction.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case commentaction.FieldCommentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCommentID(v)
		return nil
	}
	return fmt.Errorf("unknown CommentAction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommentActionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommentActionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommentActionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CommentAction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommentActionMutation) ResetField(name string) error {
	switch name {
	case commentaction.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case commentaction.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case commentaction.FieldUserID:
		m.ResetUserID()
		return nil
	case commentaction.FieldCommentID:
		m.ResetCommentID()
		return nil
	case commentaction.FieldActionType:
		m.ResetActionType()
		return nil
	}
	return fmt.Errorf("unknown CommentAction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommentActionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommentActionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommentActionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommentActionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommentActionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommentActionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommentActionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CommentAction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommentActionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CommentAction edge %s", name)
}

// OAuthProviderMutation represents an operation that mutates the OAuthProvider nodes in the graph.
type OAuthProviderMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	provider      *oauthprovider.Provider
	client_id     *string
	client_secret *string
	auth_url      *string
	token_url     *string
	user_info_url *string
	redirect_url  *string
	scopes        *[]string
	appendscopes  []string
	extra_config  *map[string]interface{}
	enabled       *bool
	sort_order    *int
	addsort_order *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*OAuthProvider, error)
	predicates    []predicate.OAuthProvider
}

var _ ent.Mutation = (*OAuthProviderMutation)(nil)

// oauthproviderOption allows management of the mutation configuration using functional options.
type oauthproviderOption func(*OAuthProviderMutation)

// newOAuthProviderMutation creates new mutation for the OAuthProvider entity.
func newOAuthProviderMutation(c config, op Op, opts ...oauthproviderOption) *OAuthProviderMutation {
	m := &OAuthProviderMutation{
		config:        c,
		op:            op,
		typ:           TypeOAuthProvider,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOAuthProviderID sets the ID field of the mutation.
func withOAuthProviderID(id int) oauthproviderOption {
	return func(m *OAuthProviderMutation) {
		var (
			err   error
			once  sync.Once
			value *OAuthProvider
		)
		m.oldValue = func(ctx context.Context) (*OAuthProvider, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OAuthProvider.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOAuthProvider sets the old OAuthProvider of the mutation.
func withOAuthProvider(node *OAuthProvider) oauthproviderOption {
	return func(m *OAuthProviderMutation) {
		m.oldValue = func(context.Context) (*OAuthProvider, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OAuthProviderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OAuthProviderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OAuthProvider entities.
func (m *OAuthProviderMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OAuthProviderMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OAuthProviderMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OAuthProvider.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OAuthProviderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OAuthProviderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OAuthProvider entity.
// If the OAuthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthProviderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OAuthProviderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OAuthProviderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OAuthProviderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OAuthProvider entity.
// If the OAuthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthProviderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OAuthProviderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetProvider sets the "provider" field.
func (m *OAuthProviderMutation) SetProvider(o oauthprovider.Provider) {
	m.provider = &o
}

// Provider returns the value of the "provider" field in the mutation.
func (m *OAuthProviderMutation) Provider() (r oauthprovider.Provider, exists bool) {
	v := m.provider
	if v == nil {
		return
	}
	return *v, true
}

// OldProvider returns the old "provider" field's value of the OAuthProvider entity.
// If the OAuthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthProviderMutation) OldProvider(ctx context.Context) (v oauthprovider.Provider, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvider: %w", err)
	}
	return oldValue.Provider, nil
}

// ResetProvider resets all changes to the "provider" field.
func (m *OAuthProviderMutation) ResetProvider() {
	m.provider = nil
}

// SetClientID sets the "client_id" field.
func (m *OAuthProviderMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *OAuthProviderMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the OAuthProvider entity.
// If the OAuthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthProviderMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ClearClientID clears the value of the "client_id" field.
func (m *OAuthProviderMutation) ClearClientID() {
	m.client_id = nil
	m.clearedFields[oauthprovider.FieldClientID] = struct{}{}
}

// ClientIDCleared returns if the "client_id" field was cleared in this mutation.
func (m *OAuthProviderMutation) ClientIDCleared() bool {
	_, ok := m.clearedFields[oauthprovider.FieldClientID]
	return ok
}

// ResetClientID resets all changes to the "client_id" field.
func (m *OAuthProviderMutation) ResetClientID() {
	m.client_id = nil
	delete(m.clearedFields, oauthprovider.FieldClientID)
}

// SetClientSecret sets the "client_secret" field.
func (m *OAuthProviderMutation) SetClientSecret(s string) {
	m.client_secret = &s
}

// ClientSecret returns the value of the "client_secret" field in the mutation.
func (m *OAuthProviderMutation) ClientSecret() (r string, exists bool) {
	v := m.client_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldClientSecret returns the old "client_secret" field's value of the OAuthProvider entity.
// If the OAuthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthProviderMutation) OldClientSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientSecret: %w", err)
	}
	return oldValue.ClientSecret, nil
}

// ClearClientSecret clears the value of the "client_secret" field.
func (m *OAuthProviderMutation) ClearClientSecret() {
	m.client_secret = nil
	m.clearedFields[oauthprovider.FieldClientSecret] = struct{}{}
}

// ClientSecretCleared returns if the "client_secret" field was cleared in this mutation.
func (m *OAuthProviderMutation) ClientSecretCleared() bool {
	_, ok := m.clearedFields[oauthprovider.FieldClientSecret]
	return ok
}

// ResetClientSecret resets all changes to the "client_secret" field.
func (m *OAuthProviderMutation) ResetClientSecret() {
	m.client_secret = nil
	delete(m.clearedFields, oauthprovider.FieldClientSecret)
}

// SetAuthURL sets the "auth_url" field.
func (m *OAuthProviderMutation) SetAuthURL(s string) {
	m.auth_url = &s
}

// AuthURL returns the value of the "auth_url" field in the mutation.
func (m *OAuthProviderMutation) AuthURL() (r string, exists bool) {
	v := m.auth_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthURL returns the old "auth_url" field's value of the OAuthProvider entity.
// If the OAuthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthProviderMutation) OldAuthURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthURL: %w", err)
	}
	return oldValue.AuthURL, nil
}

// ClearAuthURL clears the value of the "auth_url" field.
func (m *OAuthProviderMutation) ClearAuthURL() {
	m.auth_url = nil
	m.clearedFields[oauthprovider.FieldAuthURL] = struct{}{}
}

// AuthURLCleared returns if the "auth_url" field was cleared in this mutation.
func (m *OAuthProviderMutation) AuthURLCleared() bool {
	_, ok := m.clearedFields[oauthprovider.FieldAuthURL]
	return ok
}

// ResetAuthURL resets all changes to the "auth_url" field.
func (m *OAuthProviderMutation) ResetAuthURL() {
	m.auth_url = nil
	delete(m.clearedFields, oauthprovider.FieldAuthURL)
}

// SetTokenURL sets the "token_url" field.
func (m *OAuthProviderMutation) SetTokenURL(s string) {
	m.token_url = &s
}

// TokenURL returns the value of the "token_url" field in the mutation.
func (m *OAuthProviderMutation) TokenURL() (r string, exists bool) {
	v := m.token_url
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenURL returns the old "token_url" field's value of the OAuthProvider entity.
// If the OAuthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthProviderMutation) OldTokenURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenURL: %w", err)
	}
	return oldValue.TokenURL, nil
}

// ClearTokenURL clears the value of the "token_url" field.
func (m *OAuthProviderMutation) ClearTokenURL() {
	m.token_url = nil
	m.clearedFields[oauthprovider.FieldTokenURL] = struct{}{}
}

// TokenURLCleared returns if the "token_url" field was cleared in this mutation.
func (m *OAuthProviderMutation) TokenURLCleared() bool {
	_, ok := m.clearedFields[oauthprovider.FieldTokenURL]
	return ok
}

// ResetTokenURL resets all changes to the "token_url" field.
func (m *OAuthProviderMutation) ResetTokenURL() {
	m.token_url = nil
	delete(m.clearedFields, oauthprovider.FieldTokenURL)
}

// SetUserInfoURL sets the "user_info_url" field.
func (m *OAuthProviderMutation) SetUserInfoURL(s string) {
	m.user_info_url = &s
}

// UserInfoURL returns the value of the "user_info_url" field in the mutation.
func (m *OAuthProviderMutation) UserInfoURL() (r string, exists bool) {
	v := m.user_info_url
	if v == nil {
		return
	}
	return *v, true
}

// OldUserInfoURL returns the old "user_info_url" field's value of the OAuthProvider entity.
// If the OAuthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthProviderMutation) OldUserInfoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserInfoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserInfoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserInfoURL: %w", err)
	}
	return oldValue.UserInfoURL, nil
}

// ClearUserInfoURL clears the value of the "user_info_url" field.
func (m *OAuthProviderMutation) ClearUserInfoURL() {
	m.user_info_url = nil
	m.clearedFields[oauthprovider.FieldUserInfoURL] = struct{}{}
}

// UserInfoURLCleared returns if the "user_info_url" field was cleared in this mutation.
func (m *OAuthProviderMutation) UserInfoURLCleared() bool {
	_, ok := m.clearedFields[oauthprovider.FieldUserInfoURL]
	return ok
}

// ResetUserInfoURL resets all changes to the "user_info_url" field.
func (m *OAuthProviderMutation) ResetUserInfoURL() {
	m.user_info_url = nil
	delete(m.clearedFields, oauthprovider.FieldUserInfoURL)
}

// SetRedirectURL sets the "redirect_url" field.
func (m *OAuthProviderMutation) SetRedirectURL(s string) {
	m.redirect_url = &s
}

// RedirectURL returns the value of the "redirect_url" field in the mutation.
func (m *OAuthProviderMutation) RedirectURL() (r string, exists bool) {
	v := m.redirect_url
	if v == nil {
		return
	}
	return *v, true
}

// OldRedirectURL returns the old "redirect_url" field's value of the OAuthProvider entity.
// If the OAuthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthProviderMutation) OldRedirectURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedirectURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedirectURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedirectURL: %w", err)
	}
	return oldValue.RedirectURL, nil
}

// ClearRedirectURL clears the value of the "redirect_url" field.
func (m *OAuthProviderMutation) ClearRedirectURL() {
	m.redirect_url = nil
	m.clearedFields[oauthprovider.FieldRedirectURL] = struct{}{}
}

// RedirectURLCleared returns if the "redirect_url" field was cleared in this mutation.
func (m *OAuthProviderMutation) RedirectURLCleared() bool {
	_, ok := m.clearedFields[oauthprovider.FieldRedirectURL]
	return ok
}

// ResetRedirectURL resets all changes to the "redirect_url" field.
func (m *OAuthProviderMutation) ResetRedirectURL() {
	m.redirect_url = nil
	delete(m.clearedFields, oauthprovider.FieldRedirectURL)
}

// SetScopes sets the "scopes" field.
func (m *OAuthProviderMutation) SetScopes(s []string) {
	m.scopes = &s
	m.appendscopes = nil
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *OAuthProviderMutation) Scopes() (r []string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the OAuthProvider entity.
// If the OAuthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthProviderMutation) OldScopes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// AppendScopes adds s to the "scopes" field.
func (m *OAuthProviderMutation) AppendScopes(s []string) {
	m.appendscopes = append(m.appendscopes, s...)
}

// AppendedScopes returns the list of values that were appended to the "scopes" field in this mutation.
func (m *OAuthProviderMutation) AppendedScopes() ([]string, bool) {
	if len(m.appendscopes) == 0 {
		return nil, false
	}
	return m.appendscopes, true
}

// ClearScopes clears the value of the "scopes" field.
func (m *OAuthProviderMutation) ClearScopes() {
	m.scopes = nil
	m.appendscopes = nil
	m.clearedFields[oauthprovider.FieldScopes] = struct{}{}
}

// ScopesCleared returns if the "scopes" field was cleared in this mutation.
func (m *OAuthProviderMutation) ScopesCleared() bool {
	_, ok := m.clearedFields[oauthprovider.FieldScopes]
	return ok
}

// ResetScopes resets all changes to the "scopes" field.
func (m *OAuthProviderMutation) ResetScopes() {
	m.scopes = nil
	m.appendscopes = nil
	delete(m.clearedFields, oauthprovider.FieldScopes)
}

// SetExtraConfig sets the "extra_config" field.
func (m *OAuthProviderMutation) SetExtraConfig(value map[string]interface{}) {
	m.extra_config = &value
}

// ExtraConfig returns the value of the "extra_config" field in the mutation.
func (m *OAuthProviderMutation) ExtraConfig() (r map[string]interface{}, exists bool) {
	v := m.extra_config
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraConfig returns the old "extra_config" field's value of the OAuthProvider entity.
// If the OAuthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthProviderMutation) OldExtraConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraConfig: %w", err)
	}
	return oldValue.ExtraConfig, nil
}

// ClearExtraConfig clears the value of the "extra_config" field.
func (m *OAuthProviderMutation) ClearExtraConfig() {
	m.extra_config = nil
	m.clearedFields[oauthprovider.FieldExtraConfig] = struct{}{}
}

// ExtraConfigCleared returns if the "extra_config" field was cleared in this mutation.
func (m *OAuthProviderMutation) ExtraConfigCleared() bool {
	_, ok := m.clearedFields[oauthprovider.FieldExtraConfig]
	return ok
}

// ResetExtraConfig resets all changes to the "extra_config" field.
func (m *OAuthProviderMutation) ResetExtraConfig() {
	m.extra_config = nil
	delete(m.clearedFields, oauthprovider.FieldExtraConfig)
}

// SetEnabled sets the "enabled" field.
func (m *OAuthProviderMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *OAuthProviderMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the OAuthProvider entity.
// If the OAuthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthProviderMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *OAuthProviderMutation) ResetEnabled() {
	m.enabled = nil
}

// SetSortOrder sets the "sort_order" field.
func (m *OAuthProviderMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *OAuthProviderMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the OAuthProvider entity.
// If the OAuthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OAuthProviderMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *OAuthProviderMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *OAuthProviderMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *OAuthProviderMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// Where appends a list predicates to the OAuthProviderMutation builder.
func (m *OAuthProviderMutation) Where(ps ...predicate.OAuthProvider) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OAuthProviderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OAuthProviderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OAuthProvider, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OAuthProviderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OAuthProviderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OAuthProvider).
func (m *OAuthProviderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OAuthProviderMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, oauthprovider.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, oauthprovider.FieldUpdatedAt)
	}
	if m.provider != nil {
		fields = append(fields, oauthprovider.FieldProvider)
	}
	if m.client_id != nil {
		fields = append(fields, oauthprovider.FieldClientID)
	}
	if m.client_secret != nil {
		fields = append(fields, oauthprovider.FieldClientSecret)
	}
	if m.auth_url != nil {
		fields = append(fields, oauthprovider.FieldAuthURL)
	}
	if m.token_url != nil {
		fields = append(fields, oauthprovider.FieldTokenURL)
	}
	if m.user_info_url != nil {
		fields = append(fields, oauthprovider.FieldUserInfoURL)
	}
	if m.redirect_url != nil {
		fields = append(fields, oauthprovider.FieldRedirectURL)
	}
	if m.scopes != nil {
		fields = append(fields, oauthprovider.FieldScopes)
	}
	if m.extra_config != nil {
		fields = append(fields, oauthprovider.FieldExtraConfig)
	}
	if m.enabled != nil {
		fields = append(fields, oauthprovider.FieldEnabled)
	}
	if m.sort_order != nil {
		fields = append(fields, oauthprovider.FieldSortOrder)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OAuthProviderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oauthprovider.FieldCreatedAt:
		return m.CreatedAt()
	case oauthprovider.FieldUpdatedAt:
		return m.UpdatedAt()
	case oauthprovider.FieldProvider:
		return m.Provider()
	case oauthprovider.FieldClientID:
		return m.ClientID()
	case oauthprovider.FieldClientSecret:
		return m.ClientSecret()
	case oauthprovider.FieldAuthURL:
		return m.AuthURL()
	case oauthprovider.FieldTokenURL:
		return m.TokenURL()
	case oauthprovider.FieldUserInfoURL:
		return m.UserInfoURL()
	case oauthprovider.FieldRedirectURL:
		return m.RedirectURL()
	case oauthprovider.FieldScopes:
		return m.Scopes()
	case oauthprovider.FieldExtraConfig:
		return m.ExtraConfig()
	case oauthprovider.FieldEnabled:
		return m.Enabled()
	case oauthprovider.FieldSortOrder:
		return m.SortOrder()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OAuthProviderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oauthprovider.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case oauthprovider.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case oauthprovider.FieldProvider:
		return m.OldProvider(ctx)
	case oauthprovider.FieldClientID:
		return m.OldClientID(ctx)
	case oauthprovider.FieldClientSecret:
		return m.OldClientSecret(ctx)
	case oauthprovider.FieldAuthURL:
		return m.OldAuthURL(ctx)
	case oauthprovider.FieldTokenURL:
		return m.OldTokenURL(ctx)
	case oauthprovider.FieldUserInfoURL:
		return m.OldUserInfoURL(ctx)
	case oauthprovider.FieldRedirectURL:
		return m.OldRedirectURL(ctx)
	case oauthprovider.FieldScopes:
		return m.OldScopes(ctx)
	case oauthprovider.FieldExtraConfig:
		return m.OldExtraConfig(ctx)
	case oauthprovider.FieldEnabled:
		return m.OldEnabled(ctx)
	case oauthprovider.FieldSortOrder:
		return m.OldSortOrder(ctx)
	}
	return nil, fmt.Errorf("unknown OAuthProvider field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OAuthProviderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oauthprovider.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case oauthprovider.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case oauthprovider.FieldProvider:
		v, ok := value.(oauthprovider.Provider)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvider(v)
		return nil
	case oauthprovider.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case oauthprovider.FieldClientSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientSecret(v)
		return nil
	case oauthprovider.FieldAuthURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthURL(v)
		return nil
	case oauthprovider.FieldTokenURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenURL(v)
		return nil
	case oauthprovider.FieldUserInfoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserInfoURL(v)
		return nil
	case oauthprovider.FieldRedirectURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedirectURL(v)
		return nil
	case oauthprovider.FieldScopes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	case oauthprovider.FieldExtraConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraConfig(v)
		return nil
	case oauthprovider.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case oauthprovider.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown OAuthProvider field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OAuthProviderMutation) AddedFields() []string {
	var fields []string
	if m.addsort_order != nil {
		fields = append(fields, oauthprovider.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OAuthProviderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case oauthprovider.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OAuthProviderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case oauthprovider.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown OAuthProvider numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OAuthProviderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(oauthprovider.FieldClientID) {
		fields = append(fields, oauthprovider.FieldClientID)
	}
	if m.FieldCleared(oauthprovider.FieldClientSecret) {
		fields = append(fields, oauthprovider.FieldClientSecret)
	}
	if m.FieldCleared(oauthprovider.FieldAuthURL) {
		fields = append(fields, oauthprovider.FieldAuthURL)
	}
	if m.FieldCleared(oauthprovider.FieldTokenURL) {
		fields = append(fields, oauthprovider.FieldTokenURL)
	}
	if m.FieldCleared(oauthprovider.FieldUserInfoURL) {
		fields = append(fields, oauthprovider.FieldUserInfoURL)
	}
	if m.FieldCleared(oauthprovider.FieldRedirectURL) {
		fields = append(fields, oauthprovider.FieldRedirectURL)
	}
	if m.FieldCleared(oauthprovider.FieldScopes) {
		fields = append(fields, oauthprovider.FieldScopes)
	}
	if m.FieldCleared(oauthprovider.FieldExtraConfig) {
		fields = append(fields, oauthprovider.FieldExtraConfig)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OAuthProviderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OAuthProviderMutation) ClearField(name string) error {
	switch name {
	case oauthprovider.FieldClientID:
		m.ClearClientID()
		return nil
	case oauthprovider.FieldClientSecret:
		m.ClearClientSecret()
		return nil
	case oauthprovider.FieldAuthURL:
		m.ClearAuthURL()
		return nil
	case oauthprovider.FieldTokenURL:
		m.ClearTokenURL()
		return nil
	case oauthprovider.FieldUserInfoURL:
		m.ClearUserInfoURL()
		return nil
	case oauthprovider.FieldRedirectURL:
		m.ClearRedirectURL()
		return nil
	case oauthprovider.FieldScopes:
		m.ClearScopes()
		return nil
	case oauthprovider.FieldExtraConfig:
		m.ClearExtraConfig()
		return nil
	}
	return fmt.Errorf("unknown OAuthProvider nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OAuthProviderMutation) ResetField(name string) error {
	switch name {
	case oauthprovider.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case oauthprovider.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case oauthprovider.FieldProvider:
		m.ResetProvider()
		return nil
	case oauthprovider.FieldClientID:
		m.ResetClientID()
		return nil
	case oauthprovider.FieldClientSecret:
		m.ResetClientSecret()
		return nil
	case oauthprovider.FieldAuthURL:
		m.ResetAuthURL()
		return nil
	case oauthprovider.FieldTokenURL:
		m.ResetTokenURL()
		return nil
	case oauthprovider.FieldUserInfoURL:
		m.ResetUserInfoURL()
		return nil
	case oauthprovider.FieldRedirectURL:
		m.ResetRedirectURL()
		return nil
	case oauthprovider.FieldScopes:
		m.ResetScopes()
		return nil
	case oauthprovider.FieldExtraConfig:
		m.ResetExtraConfig()
		return nil
	case oauthprovider.FieldEnabled:
		m.ResetEnabled()
		return nil
	case oauthprovider.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	}
	return fmt.Errorf("unknown OAuthProvider field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OAuthProviderMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OAuthProviderMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OAuthProviderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OAuthProviderMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OAuthProviderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OAuthProviderMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OAuthProviderMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OAuthProvider unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OAuthProviderMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OAuthProvider edge %s", name)
}

// PostMutation represents an operation that mutates the Post nodes in the graph.
type PostMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	user_id           *int
	adduser_id        *int
	category_id       *int
	addcategory_id    *int
	title             *string
	content           *string
	read_permission   *string
	view_count        *int
	addview_count     *int
	like_count        *int
	addlike_count     *int
	dislike_count     *int
	adddislike_count  *int
	favorite_count    *int
	addfavorite_count *int
	is_essence        *bool
	is_pinned         *bool
	publish_ip        *string
	status            *post.Status
	last_edited_at    *time.Time
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*Post, error)
	predicates        []predicate.Post
}

var _ ent.Mutation = (*PostMutation)(nil)

// postOption allows management of the mutation configuration using functional options.
type postOption func(*PostMutation)

// newPostMutation creates new mutation for the Post entity.
func newPostMutation(c config, op Op, opts ...postOption) *PostMutation {
	m := &PostMutation{
		config:        c,
		op:            op,
		typ:           TypePost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPostID sets the ID field of the mutation.
func withPostID(id int) postOption {
	return func(m *PostMutation) {
		var (
			err   error
			once  sync.Once
			value *Post
		)
		m.oldValue = func(ctx context.Context) (*Post, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Post.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPost sets the old Post of the mutation.
func withPost(node *Post) postOption {
	return func(m *PostMutation) {
		m.oldValue = func(context.Context) (*Post, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Post entities.
func (m *PostMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PostMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PostMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Post.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PostMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PostMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PostMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PostMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PostMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PostMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *PostMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *PostMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *PostMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *PostMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *PostMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetCategoryID sets the "category_id" field.
func (m *PostMutation) SetCategoryID(i int) {
	m.category_id = &i
	m.addcategory_id = nil
}

// CategoryID returns the value of the "category_id" field in the mutation.
func (m *PostMutation) CategoryID() (r int, exists bool) {
	v := m.category_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "category_id" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldCategoryID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// AddCategoryID adds i to the "category_id" field.
func (m *PostMutation) AddCategoryID(i int) {
	if m.addcategory_id != nil {
		*m.addcategory_id += i
	} else {
		m.addcategory_id = &i
	}
}

// AddedCategoryID returns the value that was added to the "category_id" field in this mutation.
func (m *PostMutation) AddedCategoryID() (r int, exists bool) {
	v := m.addcategory_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCategoryID resets all changes to the "category_id" field.
func (m *PostMutation) ResetCategoryID() {
	m.category_id = nil
	m.addcategory_id = nil
}

// SetTitle sets the "title" field.
func (m *PostMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *PostMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *PostMutation) ResetTitle() {
	m.title = nil
}

// SetContent sets the "content" field.
func (m *PostMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *PostMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *PostMutation) ResetContent() {
	m.content = nil
}

// SetReadPermission sets the "read_permission" field.
func (m *PostMutation) SetReadPermission(s string) {
	m.read_permission = &s
}

// ReadPermission returns the value of the "read_permission" field in the mutation.
func (m *PostMutation) ReadPermission() (r string, exists bool) {
	v := m.read_permission
	if v == nil {
		return
	}
	return *v, true
}

// OldReadPermission returns the old "read_permission" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldReadPermission(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReadPermission is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReadPermission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReadPermission: %w", err)
	}
	return oldValue.ReadPermission, nil
}

// ClearReadPermission clears the value of the "read_permission" field.
func (m *PostMutation) ClearReadPermission() {
	m.read_permission = nil
	m.clearedFields[post.FieldReadPermission] = struct{}{}
}

// ReadPermissionCleared returns if the "read_permission" field was cleared in this mutation.
func (m *PostMutation) ReadPermissionCleared() bool {
	_, ok := m.clearedFields[post.FieldReadPermission]
	return ok
}

// ResetReadPermission resets all changes to the "read_permission" field.
func (m *PostMutation) ResetReadPermission() {
	m.read_permission = nil
	delete(m.clearedFields, post.FieldReadPermission)
}

// SetViewCount sets the "view_count" field.
func (m *PostMutation) SetViewCount(i int) {
	m.view_count = &i
	m.addview_count = nil
}

// ViewCount returns the value of the "view_count" field in the mutation.
func (m *PostMutation) ViewCount() (r int, exists bool) {
	v := m.view_count
	if v == nil {
		return
	}
	return *v, true
}

// OldViewCount returns the old "view_count" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldViewCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldViewCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldViewCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldViewCount: %w", err)
	}
	return oldValue.ViewCount, nil
}

// AddViewCount adds i to the "view_count" field.
func (m *PostMutation) AddViewCount(i int) {
	if m.addview_count != nil {
		*m.addview_count += i
	} else {
		m.addview_count = &i
	}
}

// AddedViewCount returns the value that was added to the "view_count" field in this mutation.
func (m *PostMutation) AddedViewCount() (r int, exists bool) {
	v := m.addview_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetViewCount resets all changes to the "view_count" field.
func (m *PostMutation) ResetViewCount() {
	m.view_count = nil
	m.addview_count = nil
}

// SetLikeCount sets the "like_count" field.
func (m *PostMutation) SetLikeCount(i int) {
	m.like_count = &i
	m.addlike_count = nil
}

// LikeCount returns the value of the "like_count" field in the mutation.
func (m *PostMutation) LikeCount() (r int, exists bool) {
	v := m.like_count
	if v == nil {
		return
	}
	return *v, true
}

// OldLikeCount returns the old "like_count" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldLikeCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLikeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLikeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLikeCount: %w", err)
	}
	return oldValue.LikeCount, nil
}

// AddLikeCount adds i to the "like_count" field.
func (m *PostMutation) AddLikeCount(i int) {
	if m.addlike_count != nil {
		*m.addlike_count += i
	} else {
		m.addlike_count = &i
	}
}

// AddedLikeCount returns the value that was added to the "like_count" field in this mutation.
func (m *PostMutation) AddedLikeCount() (r int, exists bool) {
	v := m.addlike_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetLikeCount resets all changes to the "like_count" field.
func (m *PostMutation) ResetLikeCount() {
	m.like_count = nil
	m.addlike_count = nil
}

// SetDislikeCount sets the "dislike_count" field.
func (m *PostMutation) SetDislikeCount(i int) {
	m.dislike_count = &i
	m.adddislike_count = nil
}

// DislikeCount returns the value of the "dislike_count" field in the mutation.
func (m *PostMutation) DislikeCount() (r int, exists bool) {
	v := m.dislike_count
	if v == nil {
		return
	}
	return *v, true
}

// OldDislikeCount returns the old "dislike_count" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldDislikeCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDislikeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDislikeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDislikeCount: %w", err)
	}
	return oldValue.DislikeCount, nil
}

// AddDislikeCount adds i to the "dislike_count" field.
func (m *PostMutation) AddDislikeCount(i int) {
	if m.adddislike_count != nil {
		*m.adddislike_count += i
	} else {
		m.adddislike_count = &i
	}
}

// AddedDislikeCount returns the value that was added to the "dislike_count" field in this mutation.
func (m *PostMutation) AddedDislikeCount() (r int, exists bool) {
	v := m.adddislike_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetDislikeCount resets all changes to the "dislike_count" field.
func (m *PostMutation) ResetDislikeCount() {
	m.dislike_count = nil
	m.adddislike_count = nil
}

// SetFavoriteCount sets the "favorite_count" field.
func (m *PostMutation) SetFavoriteCount(i int) {
	m.favorite_count = &i
	m.addfavorite_count = nil
}

// FavoriteCount returns the value of the "favorite_count" field in the mutation.
func (m *PostMutation) FavoriteCount() (r int, exists bool) {
	v := m.favorite_count
	if v == nil {
		return
	}
	return *v, true
}

// OldFavoriteCount returns the old "favorite_count" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldFavoriteCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFavoriteCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFavoriteCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFavoriteCount: %w", err)
	}
	return oldValue.FavoriteCount, nil
}

// AddFavoriteCount adds i to the "favorite_count" field.
func (m *PostMutation) AddFavoriteCount(i int) {
	if m.addfavorite_count != nil {
		*m.addfavorite_count += i
	} else {
		m.addfavorite_count = &i
	}
}

// AddedFavoriteCount returns the value that was added to the "favorite_count" field in this mutation.
func (m *PostMutation) AddedFavoriteCount() (r int, exists bool) {
	v := m.addfavorite_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetFavoriteCount resets all changes to the "favorite_count" field.
func (m *PostMutation) ResetFavoriteCount() {
	m.favorite_count = nil
	m.addfavorite_count = nil
}

// SetIsEssence sets the "is_essence" field.
func (m *PostMutation) SetIsEssence(b bool) {
	m.is_essence = &b
}

// IsEssence returns the value of the "is_essence" field in the mutation.
func (m *PostMutation) IsEssence() (r bool, exists bool) {
	v := m.is_essence
	if v == nil {
		return
	}
	return *v, true
}

// OldIsEssence returns the old "is_essence" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldIsEssence(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsEssence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsEssence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsEssence: %w", err)
	}
	return oldValue.IsEssence, nil
}

// ResetIsEssence resets all changes to the "is_essence" field.
func (m *PostMutation) ResetIsEssence() {
	m.is_essence = nil
}

// SetIsPinned sets the "is_pinned" field.
func (m *PostMutation) SetIsPinned(b bool) {
	m.is_pinned = &b
}

// IsPinned returns the value of the "is_pinned" field in the mutation.
func (m *PostMutation) IsPinned() (r bool, exists bool) {
	v := m.is_pinned
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPinned returns the old "is_pinned" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldIsPinned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPinned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPinned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPinned: %w", err)
	}
	return oldValue.IsPinned, nil
}

// ResetIsPinned resets all changes to the "is_pinned" field.
func (m *PostMutation) ResetIsPinned() {
	m.is_pinned = nil
}

// SetPublishIP sets the "publish_ip" field.
func (m *PostMutation) SetPublishIP(s string) {
	m.publish_ip = &s
}

// PublishIP returns the value of the "publish_ip" field in the mutation.
func (m *PostMutation) PublishIP() (r string, exists bool) {
	v := m.publish_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldPublishIP returns the old "publish_ip" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldPublishIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublishIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublishIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublishIP: %w", err)
	}
	return oldValue.PublishIP, nil
}

// ClearPublishIP clears the value of the "publish_ip" field.
func (m *PostMutation) ClearPublishIP() {
	m.publish_ip = nil
	m.clearedFields[post.FieldPublishIP] = struct{}{}
}

// PublishIPCleared returns if the "publish_ip" field was cleared in this mutation.
func (m *PostMutation) PublishIPCleared() bool {
	_, ok := m.clearedFields[post.FieldPublishIP]
	return ok
}

// ResetPublishIP resets all changes to the "publish_ip" field.
func (m *PostMutation) ResetPublishIP() {
	m.publish_ip = nil
	delete(m.clearedFields, post.FieldPublishIP)
}

// SetStatus sets the "status" field.
func (m *PostMutation) SetStatus(po post.Status) {
	m.status = &po
}

// Status returns the value of the "status" field in the mutation.
func (m *PostMutation) Status() (r post.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldStatus(ctx context.Context) (v post.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PostMutation) ResetStatus() {
	m.status = nil
}

// SetLastEditedAt sets the "last_edited_at" field.
func (m *PostMutation) SetLastEditedAt(t time.Time) {
	m.last_edited_at = &t
}

// LastEditedAt returns the value of the "last_edited_at" field in the mutation.
func (m *PostMutation) LastEditedAt() (r time.Time, exists bool) {
	v := m.last_edited_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastEditedAt returns the old "last_edited_at" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldLastEditedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastEditedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastEditedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastEditedAt: %w", err)
	}
	return oldValue.LastEditedAt, nil
}

// ClearLastEditedAt clears the value of the "last_edited_at" field.
func (m *PostMutation) ClearLastEditedAt() {
	m.last_edited_at = nil
	m.clearedFields[post.FieldLastEditedAt] = struct{}{}
}

// LastEditedAtCleared returns if the "last_edited_at" field was cleared in this mutation.
func (m *PostMutation) LastEditedAtCleared() bool {
	_, ok := m.clearedFields[post.FieldLastEditedAt]
	return ok
}

// ResetLastEditedAt resets all changes to the "last_edited_at" field.
func (m *PostMutation) ResetLastEditedAt() {
	m.last_edited_at = nil
	delete(m.clearedFields, post.FieldLastEditedAt)
}

// Where appends a list predicates to the PostMutation builder.
func (m *PostMutation) Where(ps ...predicate.Post) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PostMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PostMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Post, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PostMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PostMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Post).
func (m *PostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PostMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, post.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, post.FieldUpdatedAt)
	}
	if m.user_id != nil {
		fields = append(fields, post.FieldUserID)
	}
	if m.category_id != nil {
		fields = append(fields, post.FieldCategoryID)
	}
	if m.title != nil {
		fields = append(fields, post.FieldTitle)
	}
	if m.content != nil {
		fields = append(fields, post.FieldContent)
	}
	if m.read_permission != nil {
		fields = append(fields, post.FieldReadPermission)
	}
	if m.view_count != nil {
		fields = append(fields, post.FieldViewCount)
	}
	if m.like_count != nil {
		fields = append(fields, post.FieldLikeCount)
	}
	if m.dislike_count != nil {
		fields = append(fields, post.FieldDislikeCount)
	}
	if m.favorite_count != nil {
		fields = append(fields, post.FieldFavoriteCount)
	}
	if m.is_essence != nil {
		fields = append(fields, post.FieldIsEssence)
	}
	if m.is_pinned != nil {
		fields = append(fields, post.FieldIsPinned)
	}
	if m.publish_ip != nil {
		fields = append(fields, post.FieldPublishIP)
	}
	if m.status != nil {
		fields = append(fields, post.FieldStatus)
	}
	if m.last_edited_at != nil {
		fields = append(fields, post.FieldLastEditedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case post.FieldCreatedAt:
		return m.CreatedAt()
	case post.FieldUpdatedAt:
		return m.UpdatedAt()
	case post.FieldUserID:
		return m.UserID()
	case post.FieldCategoryID:
		return m.CategoryID()
	case post.FieldTitle:
		return m.Title()
	case post.FieldContent:
		return m.Content()
	case post.FieldReadPermission:
		return m.ReadPermission()
	case post.FieldViewCount:
		return m.ViewCount()
	case post.FieldLikeCount:
		return m.LikeCount()
	case post.FieldDislikeCount:
		return m.DislikeCount()
	case post.FieldFavoriteCount:
		return m.FavoriteCount()
	case post.FieldIsEssence:
		return m.IsEssence()
	case post.FieldIsPinned:
		return m.IsPinned()
	case post.FieldPublishIP:
		return m.PublishIP()
	case post.FieldStatus:
		return m.Status()
	case post.FieldLastEditedAt:
		return m.LastEditedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case post.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case post.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case post.FieldUserID:
		return m.OldUserID(ctx)
	case post.FieldCategoryID:
		return m.OldCategoryID(ctx)
	case post.FieldTitle:
		return m.OldTitle(ctx)
	case post.FieldContent:
		return m.OldContent(ctx)
	case post.FieldReadPermission:
		return m.OldReadPermission(ctx)
	case post.FieldViewCount:
		return m.OldViewCount(ctx)
	case post.FieldLikeCount:
		return m.OldLikeCount(ctx)
	case post.FieldDislikeCount:
		return m.OldDislikeCount(ctx)
	case post.FieldFavoriteCount:
		return m.OldFavoriteCount(ctx)
	case post.FieldIsEssence:
		return m.OldIsEssence(ctx)
	case post.FieldIsPinned:
		return m.OldIsPinned(ctx)
	case post.FieldPublishIP:
		return m.OldPublishIP(ctx)
	case post.FieldStatus:
		return m.OldStatus(ctx)
	case post.FieldLastEditedAt:
		return m.OldLastEditedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Post field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case post.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case post.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case post.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case post.FieldCategoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	case post.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case post.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case post.FieldReadPermission:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReadPermission(v)
		return nil
	case post.FieldViewCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetViewCount(v)
		return nil
	case post.FieldLikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikeCount(v)
		return nil
	case post.FieldDislikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDislikeCount(v)
		return nil
	case post.FieldFavoriteCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFavoriteCount(v)
		return nil
	case post.FieldIsEssence:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsEssence(v)
		return nil
	case post.FieldIsPinned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPinned(v)
		return nil
	case post.FieldPublishIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublishIP(v)
		return nil
	case post.FieldStatus:
		v, ok := value.(post.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case post.FieldLastEditedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastEditedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Post field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PostMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, post.FieldUserID)
	}
	if m.addcategory_id != nil {
		fields = append(fields, post.FieldCategoryID)
	}
	if m.addview_count != nil {
		fields = append(fields, post.FieldViewCount)
	}
	if m.addlike_count != nil {
		fields = append(fields, post.FieldLikeCount)
	}
	if m.adddislike_count != nil {
		fields = append(fields, post.FieldDislikeCount)
	}
	if m.addfavorite_count != nil {
		fields = append(fields, post.FieldFavoriteCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PostMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case post.FieldUserID:
		return m.AddedUserID()
	case post.FieldCategoryID:
		return m.AddedCategoryID()
	case post.FieldViewCount:
		return m.AddedViewCount()
	case post.FieldLikeCount:
		return m.AddedLikeCount()
	case post.FieldDislikeCount:
		return m.AddedDislikeCount()
	case post.FieldFavoriteCount:
		return m.AddedFavoriteCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostMutation) AddField(name string, value ent.Value) error {
	switch name {
	case post.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case post.FieldCategoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCategoryID(v)
		return nil
	case post.FieldViewCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddViewCount(v)
		return nil
	case post.FieldLikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLikeCount(v)
		return nil
	case post.FieldDislikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDislikeCount(v)
		return nil
	case post.FieldFavoriteCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFavoriteCount(v)
		return nil
	}
	return fmt.Errorf("unknown Post numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PostMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(post.FieldReadPermission) {
		fields = append(fields, post.FieldReadPermission)
	}
	if m.FieldCleared(post.FieldPublishIP) {
		fields = append(fields, post.FieldPublishIP)
	}
	if m.FieldCleared(post.FieldLastEditedAt) {
		fields = append(fields, post.FieldLastEditedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PostMutation) ClearField(name string) error {
	switch name {
	case post.FieldReadPermission:
		m.ClearReadPermission()
		return nil
	case post.FieldPublishIP:
		m.ClearPublishIP()
		return nil
	case post.FieldLastEditedAt:
		m.ClearLastEditedAt()
		return nil
	}
	return fmt.Errorf("unknown Post nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PostMutation) ResetField(name string) error {
	switch name {
	case post.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case post.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case post.FieldUserID:
		m.ResetUserID()
		return nil
	case post.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	case post.FieldTitle:
		m.ResetTitle()
		return nil
	case post.FieldContent:
		m.ResetContent()
		return nil
	case post.FieldReadPermission:
		m.ResetReadPermission()
		return nil
	case post.FieldViewCount:
		m.ResetViewCount()
		return nil
	case post.FieldLikeCount:
		m.ResetLikeCount()
		return nil
	case post.FieldDislikeCount:
		m.ResetDislikeCount()
		return nil
	case post.FieldFavoriteCount:
		m.ResetFavoriteCount()
		return nil
	case post.FieldIsEssence:
		m.ResetIsEssence()
		return nil
	case post.FieldIsPinned:
		m.ResetIsPinned()
		return nil
	case post.FieldPublishIP:
		m.ResetPublishIP()
		return nil
	case post.FieldStatus:
		m.ResetStatus()
		return nil
	case post.FieldLastEditedAt:
		m.ResetLastEditedAt()
		return nil
	}
	return fmt.Errorf("unknown Post field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PostMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PostMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PostMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PostMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PostMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Post unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PostMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Post edge %s", name)
}

// PostActionMutation represents an operation that mutates the PostAction nodes in the graph.
type PostActionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	user_id       *int
	adduser_id    *int
	post_id       *int
	addpost_id    *int
	action_type   *postaction.ActionType
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*PostAction, error)
	predicates    []predicate.PostAction
}

var _ ent.Mutation = (*PostActionMutation)(nil)

// postactionOption allows management of the mutation configuration using functional options.
type postactionOption func(*PostActionMutation)

// newPostActionMutation creates new mutation for the PostAction entity.
func newPostActionMutation(c config, op Op, opts ...postactionOption) *PostActionMutation {
	m := &PostActionMutation{
		config:        c,
		op:            op,
		typ:           TypePostAction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPostActionID sets the ID field of the mutation.
func withPostActionID(id int) postactionOption {
	return func(m *PostActionMutation) {
		var (
			err   error
			once  sync.Once
			value *PostAction
		)
		m.oldValue = func(ctx context.Context) (*PostAction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PostAction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPostAction sets the old PostAction of the mutation.
func withPostAction(node *PostAction) postactionOption {
	return func(m *PostActionMutation) {
		m.oldValue = func(context.Context) (*PostAction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PostActionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PostActionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PostAction entities.
func (m *PostActionMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PostActionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PostActionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PostAction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PostActionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PostActionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PostAction entity.
// If the PostAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostActionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PostActionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PostActionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PostActionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PostAction entity.
// If the PostAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostActionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PostActionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *PostActionMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *PostActionMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the PostAction entity.
// If the PostAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostActionMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *PostActionMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *PostActionMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *PostActionMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetPostID sets the "post_id" field.
func (m *PostActionMutation) SetPostID(i int) {
	m.post_id = &i
	m.addpost_id = nil
}

// PostID returns the value of the "post_id" field in the mutation.
func (m *PostActionMutation) PostID() (r int, exists bool) {
	v := m.post_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPostID returns the old "post_id" field's value of the PostAction entity.
// If the PostAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostActionMutation) OldPostID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostID: %w", err)
	}
	return oldValue.PostID, nil
}

// AddPostID adds i to the "post_id" field.
func (m *PostActionMutation) AddPostID(i int) {
	if m.addpost_id != nil {
		*m.addpost_id += i
	} else {
		m.addpost_id = &i
	}
}

// AddedPostID returns the value that was added to the "post_id" field in this mutation.
func (m *PostActionMutation) AddedPostID() (r int, exists bool) {
	v := m.addpost_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetPostID resets all changes to the "post_id" field.
func (m *PostActionMutation) ResetPostID() {
	m.post_id = nil
	m.addpost_id = nil
}

// SetActionType sets the "action_type" field.
func (m *PostActionMutation) SetActionType(pt postaction.ActionType) {
	m.action_type = &pt
}

// ActionType returns the value of the "action_type" field in the mutation.
func (m *PostActionMutation) ActionType() (r postaction.ActionType, exists bool) {
	v := m.action_type
	if v == nil {
		return
	}
	return *v, true
}

// OldActionType returns the old "action_type" field's value of the PostAction entity.
// If the PostAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostActionMutation) OldActionType(ctx context.Context) (v postaction.ActionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionType: %w", err)
	}
	return oldValue.ActionType, nil
}

// ResetActionType resets all changes to the "action_type" field.
func (m *PostActionMutation) ResetActionType() {
	m.action_type = nil
}

// Where appends a list predicates to the PostActionMutation builder.
func (m *PostActionMutation) Where(ps ...predicate.PostAction) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PostActionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PostActionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PostAction, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PostActionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PostActionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PostAction).
func (m *PostActionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PostActionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, postaction.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, postaction.FieldUpdatedAt)
	}
	if m.user_id != nil {
		fields = append(fields, postaction.FieldUserID)
	}
	if m.post_id != nil {
		fields = append(fields, postaction.FieldPostID)
	}
	if m.action_type != nil {
		fields = append(fields, postaction.FieldActionType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PostActionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case postaction.FieldCreatedAt:
		return m.CreatedAt()
	case postaction.FieldUpdatedAt:
		return m.UpdatedAt()
	case postaction.FieldUserID:
		return m.UserID()
	case postaction.FieldPostID:
		return m.PostID()
	case postaction.FieldActionType:
		return m.ActionType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PostActionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case postaction.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case postaction.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case postaction.FieldUserID:
		return m.OldUserID(ctx)
	case postaction.FieldPostID:
		return m.OldPostID(ctx)
	case postaction.FieldActionType:
		return m.OldActionType(ctx)
	}
	return nil, fmt.Errorf("unknown PostAction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostActionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case postaction.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case postaction.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case postaction.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case postaction.FieldPostID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostID(v)
		return nil
	case postaction.FieldActionType:
		v, ok := value.(postaction.ActionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionType(v)
		return nil
	}
	return fmt.Errorf("unknown PostAction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PostActionMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, postaction.FieldUserID)
	}
	if m.addpost_id != nil {
		fields = append(fields, postaction.FieldPostID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PostActionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case postaction.FieldUserID:
		return m.AddedUserID()
	case postaction.FieldPostID:
		return m.AddedPostID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostActionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case postaction.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case postaction.FieldPostID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPostID(v)
		return nil
	}
	return fmt.Errorf("unknown PostAction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PostActionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PostActionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PostActionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PostAction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PostActionMutation) ResetField(name string) error {
	switch name {
	case postaction.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case postaction.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case postaction.FieldUserID:
		m.ResetUserID()
		return nil
	case postaction.FieldPostID:
		m.ResetPostID()
		return nil
	case postaction.FieldActionType:
		m.ResetActionType()
		return nil
	}
	return fmt.Errorf("unknown PostAction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PostActionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PostActionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PostActionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PostActionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PostActionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PostActionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PostActionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PostAction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PostActionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PostAction edge %s", name)
}

// SettingsMutation represents an operation that mutates the Settings nodes in the graph.
type SettingsMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	module        *settings.Module
	key           *string
	value         *string
	value_type    *settings.ValueType
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Settings, error)
	predicates    []predicate.Settings
}

var _ ent.Mutation = (*SettingsMutation)(nil)

// settingsOption allows management of the mutation configuration using functional options.
type settingsOption func(*SettingsMutation)

// newSettingsMutation creates new mutation for the Settings entity.
func newSettingsMutation(c config, op Op, opts ...settingsOption) *SettingsMutation {
	m := &SettingsMutation{
		config:        c,
		op:            op,
		typ:           TypeSettings,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSettingsID sets the ID field of the mutation.
func withSettingsID(id int) settingsOption {
	return func(m *SettingsMutation) {
		var (
			err   error
			once  sync.Once
			value *Settings
		)
		m.oldValue = func(ctx context.Context) (*Settings, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Settings.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSettings sets the old Settings of the mutation.
func withSettings(node *Settings) settingsOption {
	return func(m *SettingsMutation) {
		m.oldValue = func(context.Context) (*Settings, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SettingsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SettingsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Settings entities.
func (m *SettingsMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SettingsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SettingsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Settings.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SettingsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SettingsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SettingsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SettingsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SettingsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SettingsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetModule sets the "module" field.
func (m *SettingsMutation) SetModule(s settings.Module) {
	m.module = &s
}

// Module returns the value of the "module" field in the mutation.
func (m *SettingsMutation) Module() (r settings.Module, exists bool) {
	v := m.module
	if v == nil {
		return
	}
	return *v, true
}

// OldModule returns the old "module" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldModule(ctx context.Context) (v settings.Module, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModule is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModule requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModule: %w", err)
	}
	return oldValue.Module, nil
}

// ResetModule resets all changes to the "module" field.
func (m *SettingsMutation) ResetModule() {
	m.module = nil
}

// SetKey sets the "key" field.
func (m *SettingsMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *SettingsMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *SettingsMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *SettingsMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *SettingsMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ClearValue clears the value of the "value" field.
func (m *SettingsMutation) ClearValue() {
	m.value = nil
	m.clearedFields[settings.FieldValue] = struct{}{}
}

// ValueCleared returns if the "value" field was cleared in this mutation.
func (m *SettingsMutation) ValueCleared() bool {
	_, ok := m.clearedFields[settings.FieldValue]
	return ok
}

// ResetValue resets all changes to the "value" field.
func (m *SettingsMutation) ResetValue() {
	m.value = nil
	delete(m.clearedFields, settings.FieldValue)
}

// SetValueType sets the "value_type" field.
func (m *SettingsMutation) SetValueType(st settings.ValueType) {
	m.value_type = &st
}

// ValueType returns the value of the "value_type" field in the mutation.
func (m *SettingsMutation) ValueType() (r settings.ValueType, exists bool) {
	v := m.value_type
	if v == nil {
		return
	}
	return *v, true
}

// OldValueType returns the old "value_type" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldValueType(ctx context.Context) (v settings.ValueType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValueType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValueType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValueType: %w", err)
	}
	return oldValue.ValueType, nil
}

// ResetValueType resets all changes to the "value_type" field.
func (m *SettingsMutation) ResetValueType() {
	m.value_type = nil
}

// Where appends a list predicates to the SettingsMutation builder.
func (m *SettingsMutation) Where(ps ...predicate.Settings) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SettingsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SettingsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Settings, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SettingsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SettingsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Settings).
func (m *SettingsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SettingsMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, settings.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, settings.FieldUpdatedAt)
	}
	if m.module != nil {
		fields = append(fields, settings.FieldModule)
	}
	if m.key != nil {
		fields = append(fields, settings.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, settings.FieldValue)
	}
	if m.value_type != nil {
		fields = append(fields, settings.FieldValueType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SettingsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case settings.FieldCreatedAt:
		return m.CreatedAt()
	case settings.FieldUpdatedAt:
		return m.UpdatedAt()
	case settings.FieldModule:
		return m.Module()
	case settings.FieldKey:
		return m.Key()
	case settings.FieldValue:
		return m.Value()
	case settings.FieldValueType:
		return m.ValueType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SettingsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case settings.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case settings.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case settings.FieldModule:
		return m.OldModule(ctx)
	case settings.FieldKey:
		return m.OldKey(ctx)
	case settings.FieldValue:
		return m.OldValue(ctx)
	case settings.FieldValueType:
		return m.OldValueType(ctx)
	}
	return nil, fmt.Errorf("unknown Settings field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case settings.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case settings.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case settings.FieldModule:
		v, ok := value.(settings.Module)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModule(v)
		return nil
	case settings.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case settings.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case settings.FieldValueType:
		v, ok := value.(settings.ValueType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValueType(v)
		return nil
	}
	return fmt.Errorf("unknown Settings field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SettingsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SettingsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Settings numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SettingsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(settings.FieldValue) {
		fields = append(fields, settings.FieldValue)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SettingsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SettingsMutation) ClearField(name string) error {
	switch name {
	case settings.FieldValue:
		m.ClearValue()
		return nil
	}
	return fmt.Errorf("unknown Settings nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SettingsMutation) ResetField(name string) error {
	switch name {
	case settings.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case settings.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case settings.FieldModule:
		m.ResetModule()
		return nil
	case settings.FieldKey:
		m.ResetKey()
		return nil
	case settings.FieldValue:
		m.ResetValue()
		return nil
	case settings.FieldValueType:
		m.ResetValueType()
		return nil
	}
	return fmt.Errorf("unknown Settings field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SettingsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SettingsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SettingsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SettingsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SettingsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SettingsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SettingsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Settings unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SettingsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Settings edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_at       *time.Time
	updated_at       *time.Time
	email            *string
	password         *string
	password_salt    *string
	username         *string
	avatar           *string
	signature        *string
	readme           *string
	email_verified   *bool
	experience       *int
	addexperience    *int
	points           *int
	addpoints        *int
	currency         *int
	addcurrency      *int
	post_count       *int
	addpost_count    *int
	comment_count    *int
	addcomment_count *int
	status           *user.Status
	role             *user.Role
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*User, error)
	predicates       []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetPasswordSalt sets the "password_salt" field.
func (m *UserMutation) SetPasswordSalt(s string) {
	m.password_salt = &s
}

// PasswordSalt returns the value of the "password_salt" field in the mutation.
func (m *UserMutation) PasswordSalt() (r string, exists bool) {
	v := m.password_salt
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordSalt returns the old "password_salt" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordSalt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordSalt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordSalt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordSalt: %w", err)
	}
	return oldValue.PasswordSalt, nil
}

// ResetPasswordSalt resets all changes to the "password_salt" field.
func (m *UserMutation) ResetPasswordSalt() {
	m.password_salt = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetAvatar sets the "avatar" field.
func (m *UserMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *UserMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of the "avatar" field.
func (m *UserMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[user.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the "avatar" field was cleared in this mutation.
func (m *UserMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatar]
	return ok
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *UserMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, user.FieldAvatar)
}

// SetSignature sets the "signature" field.
func (m *UserMutation) SetSignature(s string) {
	m.signature = &s
}

// Signature returns the value of the "signature" field in the mutation.
func (m *UserMutation) Signature() (r string, exists bool) {
	v := m.signature
	if v == nil {
		return
	}
	return *v, true
}

// OldSignature returns the old "signature" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSignature(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignature: %w", err)
	}
	return oldValue.Signature, nil
}

// ClearSignature clears the value of the "signature" field.
func (m *UserMutation) ClearSignature() {
	m.signature = nil
	m.clearedFields[user.FieldSignature] = struct{}{}
}

// SignatureCleared returns if the "signature" field was cleared in this mutation.
func (m *UserMutation) SignatureCleared() bool {
	_, ok := m.clearedFields[user.FieldSignature]
	return ok
}

// ResetSignature resets all changes to the "signature" field.
func (m *UserMutation) ResetSignature() {
	m.signature = nil
	delete(m.clearedFields, user.FieldSignature)
}

// SetReadme sets the "readme" field.
func (m *UserMutation) SetReadme(s string) {
	m.readme = &s
}

// Readme returns the value of the "readme" field in the mutation.
func (m *UserMutation) Readme() (r string, exists bool) {
	v := m.readme
	if v == nil {
		return
	}
	return *v, true
}

// OldReadme returns the old "readme" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldReadme(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReadme is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReadme requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReadme: %w", err)
	}
	return oldValue.Readme, nil
}

// ClearReadme clears the value of the "readme" field.
func (m *UserMutation) ClearReadme() {
	m.readme = nil
	m.clearedFields[user.FieldReadme] = struct{}{}
}

// ReadmeCleared returns if the "readme" field was cleared in this mutation.
func (m *UserMutation) ReadmeCleared() bool {
	_, ok := m.clearedFields[user.FieldReadme]
	return ok
}

// ResetReadme resets all changes to the "readme" field.
func (m *UserMutation) ResetReadme() {
	m.readme = nil
	delete(m.clearedFields, user.FieldReadme)
}

// SetEmailVerified sets the "email_verified" field.
func (m *UserMutation) SetEmailVerified(b bool) {
	m.email_verified = &b
}

// EmailVerified returns the value of the "email_verified" field in the mutation.
func (m *UserMutation) EmailVerified() (r bool, exists bool) {
	v := m.email_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailVerified returns the old "email_verified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmailVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailVerified: %w", err)
	}
	return oldValue.EmailVerified, nil
}

// ResetEmailVerified resets all changes to the "email_verified" field.
func (m *UserMutation) ResetEmailVerified() {
	m.email_verified = nil
}

// SetExperience sets the "experience" field.
func (m *UserMutation) SetExperience(i int) {
	m.experience = &i
	m.addexperience = nil
}

// Experience returns the value of the "experience" field in the mutation.
func (m *UserMutation) Experience() (r int, exists bool) {
	v := m.experience
	if v == nil {
		return
	}
	return *v, true
}

// OldExperience returns the old "experience" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldExperience(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExperience is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExperience requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExperience: %w", err)
	}
	return oldValue.Experience, nil
}

// AddExperience adds i to the "experience" field.
func (m *UserMutation) AddExperience(i int) {
	if m.addexperience != nil {
		*m.addexperience += i
	} else {
		m.addexperience = &i
	}
}

// AddedExperience returns the value that was added to the "experience" field in this mutation.
func (m *UserMutation) AddedExperience() (r int, exists bool) {
	v := m.addexperience
	if v == nil {
		return
	}
	return *v, true
}

// ResetExperience resets all changes to the "experience" field.
func (m *UserMutation) ResetExperience() {
	m.experience = nil
	m.addexperience = nil
}

// SetPoints sets the "points" field.
func (m *UserMutation) SetPoints(i int) {
	m.points = &i
	m.addpoints = nil
}

// Points returns the value of the "points" field in the mutation.
func (m *UserMutation) Points() (r int, exists bool) {
	v := m.points
	if v == nil {
		return
	}
	return *v, true
}

// OldPoints returns the old "points" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPoints(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoints is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoints requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoints: %w", err)
	}
	return oldValue.Points, nil
}

// AddPoints adds i to the "points" field.
func (m *UserMutation) AddPoints(i int) {
	if m.addpoints != nil {
		*m.addpoints += i
	} else {
		m.addpoints = &i
	}
}

// AddedPoints returns the value that was added to the "points" field in this mutation.
func (m *UserMutation) AddedPoints() (r int, exists bool) {
	v := m.addpoints
	if v == nil {
		return
	}
	return *v, true
}

// ResetPoints resets all changes to the "points" field.
func (m *UserMutation) ResetPoints() {
	m.points = nil
	m.addpoints = nil
}

// SetCurrency sets the "currency" field.
func (m *UserMutation) SetCurrency(i int) {
	m.currency = &i
	m.addcurrency = nil
}

// Currency returns the value of the "currency" field in the mutation.
func (m *UserMutation) Currency() (r int, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCurrency(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// AddCurrency adds i to the "currency" field.
func (m *UserMutation) AddCurrency(i int) {
	if m.addcurrency != nil {
		*m.addcurrency += i
	} else {
		m.addcurrency = &i
	}
}

// AddedCurrency returns the value that was added to the "currency" field in this mutation.
func (m *UserMutation) AddedCurrency() (r int, exists bool) {
	v := m.addcurrency
	if v == nil {
		return
	}
	return *v, true
}

// ResetCurrency resets all changes to the "currency" field.
func (m *UserMutation) ResetCurrency() {
	m.currency = nil
	m.addcurrency = nil
}

// SetPostCount sets the "post_count" field.
func (m *UserMutation) SetPostCount(i int) {
	m.post_count = &i
	m.addpost_count = nil
}

// PostCount returns the value of the "post_count" field in the mutation.
func (m *UserMutation) PostCount() (r int, exists bool) {
	v := m.post_count
	if v == nil {
		return
	}
	return *v, true
}

// OldPostCount returns the old "post_count" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPostCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostCount: %w", err)
	}
	return oldValue.PostCount, nil
}

// AddPostCount adds i to the "post_count" field.
func (m *UserMutation) AddPostCount(i int) {
	if m.addpost_count != nil {
		*m.addpost_count += i
	} else {
		m.addpost_count = &i
	}
}

// AddedPostCount returns the value that was added to the "post_count" field in this mutation.
func (m *UserMutation) AddedPostCount() (r int, exists bool) {
	v := m.addpost_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetPostCount resets all changes to the "post_count" field.
func (m *UserMutation) ResetPostCount() {
	m.post_count = nil
	m.addpost_count = nil
}

// SetCommentCount sets the "comment_count" field.
func (m *UserMutation) SetCommentCount(i int) {
	m.comment_count = &i
	m.addcomment_count = nil
}

// CommentCount returns the value of the "comment_count" field in the mutation.
func (m *UserMutation) CommentCount() (r int, exists bool) {
	v := m.comment_count
	if v == nil {
		return
	}
	return *v, true
}

// OldCommentCount returns the old "comment_count" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCommentCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommentCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommentCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommentCount: %w", err)
	}
	return oldValue.CommentCount, nil
}

// AddCommentCount adds i to the "comment_count" field.
func (m *UserMutation) AddCommentCount(i int) {
	if m.addcomment_count != nil {
		*m.addcomment_count += i
	} else {
		m.addcomment_count = &i
	}
}

// AddedCommentCount returns the value that was added to the "comment_count" field in this mutation.
func (m *UserMutation) AddedCommentCount() (r int, exists bool) {
	v := m.addcomment_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetCommentCount resets all changes to the "comment_count" field.
func (m *UserMutation) ResetCommentCount() {
	m.comment_count = nil
	m.addcomment_count = nil
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(u user.Status) {
	m.status = &u
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r user.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v user.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(u user.Role) {
	m.role = &u
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r user.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v user.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.password_salt != nil {
		fields = append(fields, user.FieldPasswordSalt)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.avatar != nil {
		fields = append(fields, user.FieldAvatar)
	}
	if m.signature != nil {
		fields = append(fields, user.FieldSignature)
	}
	if m.readme != nil {
		fields = append(fields, user.FieldReadme)
	}
	if m.email_verified != nil {
		fields = append(fields, user.FieldEmailVerified)
	}
	if m.experience != nil {
		fields = append(fields, user.FieldExperience)
	}
	if m.points != nil {
		fields = append(fields, user.FieldPoints)
	}
	if m.currency != nil {
		fields = append(fields, user.FieldCurrency)
	}
	if m.post_count != nil {
		fields = append(fields, user.FieldPostCount)
	}
	if m.comment_count != nil {
		fields = append(fields, user.FieldCommentCount)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPassword:
		return m.Password()
	case user.FieldPasswordSalt:
		return m.PasswordSalt()
	case user.FieldUsername:
		return m.Username()
	case user.FieldAvatar:
		return m.Avatar()
	case user.FieldSignature:
		return m.Signature()
	case user.FieldReadme:
		return m.Readme()
	case user.FieldEmailVerified:
		return m.EmailVerified()
	case user.FieldExperience:
		return m.Experience()
	case user.FieldPoints:
		return m.Points()
	case user.FieldCurrency:
		return m.Currency()
	case user.FieldPostCount:
		return m.PostCount()
	case user.FieldCommentCount:
		return m.CommentCount()
	case user.FieldStatus:
		return m.Status()
	case user.FieldRole:
		return m.Role()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldPasswordSalt:
		return m.OldPasswordSalt(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldAvatar:
		return m.OldAvatar(ctx)
	case user.FieldSignature:
		return m.OldSignature(ctx)
	case user.FieldReadme:
		return m.OldReadme(ctx)
	case user.FieldEmailVerified:
		return m.OldEmailVerified(ctx)
	case user.FieldExperience:
		return m.OldExperience(ctx)
	case user.FieldPoints:
		return m.OldPoints(ctx)
	case user.FieldCurrency:
		return m.OldCurrency(ctx)
	case user.FieldPostCount:
		return m.OldPostCount(ctx)
	case user.FieldCommentCount:
		return m.OldCommentCount(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldPasswordSalt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordSalt(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case user.FieldSignature:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignature(v)
		return nil
	case user.FieldReadme:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReadme(v)
		return nil
	case user.FieldEmailVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailVerified(v)
		return nil
	case user.FieldExperience:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExperience(v)
		return nil
	case user.FieldPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoints(v)
		return nil
	case user.FieldCurrency:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case user.FieldPostCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostCount(v)
		return nil
	case user.FieldCommentCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommentCount(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(user.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldRole:
		v, ok := value.(user.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addexperience != nil {
		fields = append(fields, user.FieldExperience)
	}
	if m.addpoints != nil {
		fields = append(fields, user.FieldPoints)
	}
	if m.addcurrency != nil {
		fields = append(fields, user.FieldCurrency)
	}
	if m.addpost_count != nil {
		fields = append(fields, user.FieldPostCount)
	}
	if m.addcomment_count != nil {
		fields = append(fields, user.FieldCommentCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldExperience:
		return m.AddedExperience()
	case user.FieldPoints:
		return m.AddedPoints()
	case user.FieldCurrency:
		return m.AddedCurrency()
	case user.FieldPostCount:
		return m.AddedPostCount()
	case user.FieldCommentCount:
		return m.AddedCommentCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldExperience:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExperience(v)
		return nil
	case user.FieldPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPoints(v)
		return nil
	case user.FieldCurrency:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCurrency(v)
		return nil
	case user.FieldPostCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPostCount(v)
		return nil
	case user.FieldCommentCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCommentCount(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldAvatar) {
		fields = append(fields, user.FieldAvatar)
	}
	if m.FieldCleared(user.FieldSignature) {
		fields = append(fields, user.FieldSignature)
	}
	if m.FieldCleared(user.FieldReadme) {
		fields = append(fields, user.FieldReadme)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldAvatar:
		m.ClearAvatar()
		return nil
	case user.FieldSignature:
		m.ClearSignature()
		return nil
	case user.FieldReadme:
		m.ClearReadme()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldPasswordSalt:
		m.ResetPasswordSalt()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldAvatar:
		m.ResetAvatar()
		return nil
	case user.FieldSignature:
		m.ResetSignature()
		return nil
	case user.FieldReadme:
		m.ResetReadme()
		return nil
	case user.FieldEmailVerified:
		m.ResetEmailVerified()
		return nil
	case user.FieldExperience:
		m.ResetExperience()
		return nil
	case user.FieldPoints:
		m.ResetPoints()
		return nil
	case user.FieldCurrency:
		m.ResetCurrency()
		return nil
	case user.FieldPostCount:
		m.ResetPostCount()
		return nil
	case user.FieldCommentCount:
		m.ResetCommentCount()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}

// UserBalanceLogMutation represents an operation that mutates the UserBalanceLog nodes in the graph.
type UserBalanceLogMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_at       *time.Time
	updated_at       *time.Time
	user_id          *int
	adduser_id       *int
	_type            *userbalancelog.Type
	amount           *int
	addamount        *int
	before_amount    *int
	addbefore_amount *int
	after_amount     *int
	addafter_amount  *int
	reason           *string
	operator_id      *int
	addoperator_id   *int
	operator_name    *string
	related_id       *int
	addrelated_id    *int
	related_type     *string
	ip_address       *string
	user_agent       *string
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*UserBalanceLog, error)
	predicates       []predicate.UserBalanceLog
}

var _ ent.Mutation = (*UserBalanceLogMutation)(nil)

// userbalancelogOption allows management of the mutation configuration using functional options.
type userbalancelogOption func(*UserBalanceLogMutation)

// newUserBalanceLogMutation creates new mutation for the UserBalanceLog entity.
func newUserBalanceLogMutation(c config, op Op, opts ...userbalancelogOption) *UserBalanceLogMutation {
	m := &UserBalanceLogMutation{
		config:        c,
		op:            op,
		typ:           TypeUserBalanceLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserBalanceLogID sets the ID field of the mutation.
func withUserBalanceLogID(id int) userbalancelogOption {
	return func(m *UserBalanceLogMutation) {
		var (
			err   error
			once  sync.Once
			value *UserBalanceLog
		)
		m.oldValue = func(ctx context.Context) (*UserBalanceLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserBalanceLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserBalanceLog sets the old UserBalanceLog of the mutation.
func withUserBalanceLog(node *UserBalanceLog) userbalancelogOption {
	return func(m *UserBalanceLogMutation) {
		m.oldValue = func(context.Context) (*UserBalanceLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserBalanceLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserBalanceLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserBalanceLog entities.
func (m *UserBalanceLogMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserBalanceLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserBalanceLogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserBalanceLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserBalanceLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserBalanceLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserBalanceLog entity.
// If the UserBalanceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBalanceLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserBalanceLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserBalanceLogMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserBalanceLogMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserBalanceLog entity.
// If the UserBalanceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBalanceLogMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserBalanceLogMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *UserBalanceLogMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserBalanceLogMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserBalanceLog entity.
// If the UserBalanceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBalanceLogMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *UserBalanceLogMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *UserBalanceLogMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserBalanceLogMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetType sets the "type" field.
func (m *UserBalanceLogMutation) SetType(u userbalancelog.Type) {
	m._type = &u
}

// GetType returns the value of the "type" field in the mutation.
func (m *UserBalanceLogMutation) GetType() (r userbalancelog.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the UserBalanceLog entity.
// If the UserBalanceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBalanceLogMutation) OldType(ctx context.Context) (v userbalancelog.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *UserBalanceLogMutation) ResetType() {
	m._type = nil
}

// SetAmount sets the "amount" field.
func (m *UserBalanceLogMutation) SetAmount(i int) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *UserBalanceLogMutation) Amount() (r int, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the UserBalanceLog entity.
// If the UserBalanceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBalanceLogMutation) OldAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "amount" field.
func (m *UserBalanceLogMutation) AddAmount(i int) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *UserBalanceLogMutation) AddedAmount() (r int, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *UserBalanceLogMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetBeforeAmount sets the "before_amount" field.
func (m *UserBalanceLogMutation) SetBeforeAmount(i int) {
	m.before_amount = &i
	m.addbefore_amount = nil
}

// BeforeAmount returns the value of the "before_amount" field in the mutation.
func (m *UserBalanceLogMutation) BeforeAmount() (r int, exists bool) {
	v := m.before_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldBeforeAmount returns the old "before_amount" field's value of the UserBalanceLog entity.
// If the UserBalanceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBalanceLogMutation) OldBeforeAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBeforeAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBeforeAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBeforeAmount: %w", err)
	}
	return oldValue.BeforeAmount, nil
}

// AddBeforeAmount adds i to the "before_amount" field.
func (m *UserBalanceLogMutation) AddBeforeAmount(i int) {
	if m.addbefore_amount != nil {
		*m.addbefore_amount += i
	} else {
		m.addbefore_amount = &i
	}
}

// AddedBeforeAmount returns the value that was added to the "before_amount" field in this mutation.
func (m *UserBalanceLogMutation) AddedBeforeAmount() (r int, exists bool) {
	v := m.addbefore_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetBeforeAmount resets all changes to the "before_amount" field.
func (m *UserBalanceLogMutation) ResetBeforeAmount() {
	m.before_amount = nil
	m.addbefore_amount = nil
}

// SetAfterAmount sets the "after_amount" field.
func (m *UserBalanceLogMutation) SetAfterAmount(i int) {
	m.after_amount = &i
	m.addafter_amount = nil
}

// AfterAmount returns the value of the "after_amount" field in the mutation.
func (m *UserBalanceLogMutation) AfterAmount() (r int, exists bool) {
	v := m.after_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAfterAmount returns the old "after_amount" field's value of the UserBalanceLog entity.
// If the UserBalanceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBalanceLogMutation) OldAfterAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAfterAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAfterAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAfterAmount: %w", err)
	}
	return oldValue.AfterAmount, nil
}

// AddAfterAmount adds i to the "after_amount" field.
func (m *UserBalanceLogMutation) AddAfterAmount(i int) {
	if m.addafter_amount != nil {
		*m.addafter_amount += i
	} else {
		m.addafter_amount = &i
	}
}

// AddedAfterAmount returns the value that was added to the "after_amount" field in this mutation.
func (m *UserBalanceLogMutation) AddedAfterAmount() (r int, exists bool) {
	v := m.addafter_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAfterAmount resets all changes to the "after_amount" field.
func (m *UserBalanceLogMutation) ResetAfterAmount() {
	m.after_amount = nil
	m.addafter_amount = nil
}

// SetReason sets the "reason" field.
func (m *UserBalanceLogMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *UserBalanceLogMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the UserBalanceLog entity.
// If the UserBalanceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBalanceLogMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ResetReason resets all changes to the "reason" field.
func (m *UserBalanceLogMutation) ResetReason() {
	m.reason = nil
}

// SetOperatorID sets the "operator_id" field.
func (m *UserBalanceLogMutation) SetOperatorID(i int) {
	m.operator_id = &i
	m.addoperator_id = nil
}

// OperatorID returns the value of the "operator_id" field in the mutation.
func (m *UserBalanceLogMutation) OperatorID() (r int, exists bool) {
	v := m.operator_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOperatorID returns the old "operator_id" field's value of the UserBalanceLog entity.
// If the UserBalanceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBalanceLogMutation) OldOperatorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperatorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperatorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperatorID: %w", err)
	}
	return oldValue.OperatorID, nil
}

// AddOperatorID adds i to the "operator_id" field.
func (m *UserBalanceLogMutation) AddOperatorID(i int) {
	if m.addoperator_id != nil {
		*m.addoperator_id += i
	} else {
		m.addoperator_id = &i
	}
}

// AddedOperatorID returns the value that was added to the "operator_id" field in this mutation.
func (m *UserBalanceLogMutation) AddedOperatorID() (r int, exists bool) {
	v := m.addoperator_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearOperatorID clears the value of the "operator_id" field.
func (m *UserBalanceLogMutation) ClearOperatorID() {
	m.operator_id = nil
	m.addoperator_id = nil
	m.clearedFields[userbalancelog.FieldOperatorID] = struct{}{}
}

// OperatorIDCleared returns if the "operator_id" field was cleared in this mutation.
func (m *UserBalanceLogMutation) OperatorIDCleared() bool {
	_, ok := m.clearedFields[userbalancelog.FieldOperatorID]
	return ok
}

// ResetOperatorID resets all changes to the "operator_id" field.
func (m *UserBalanceLogMutation) ResetOperatorID() {
	m.operator_id = nil
	m.addoperator_id = nil
	delete(m.clearedFields, userbalancelog.FieldOperatorID)
}

// SetOperatorName sets the "operator_name" field.
func (m *UserBalanceLogMutation) SetOperatorName(s string) {
	m.operator_name = &s
}

// OperatorName returns the value of the "operator_name" field in the mutation.
func (m *UserBalanceLogMutation) OperatorName() (r string, exists bool) {
	v := m.operator_name
	if v == nil {
		return
	}
	return *v, true
}

// OldOperatorName returns the old "operator_name" field's value of the UserBalanceLog entity.
// If the UserBalanceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBalanceLogMutation) OldOperatorName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperatorName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperatorName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperatorName: %w", err)
	}
	return oldValue.OperatorName, nil
}

// ClearOperatorName clears the value of the "operator_name" field.
func (m *UserBalanceLogMutation) ClearOperatorName() {
	m.operator_name = nil
	m.clearedFields[userbalancelog.FieldOperatorName] = struct{}{}
}

// OperatorNameCleared returns if the "operator_name" field was cleared in this mutation.
func (m *UserBalanceLogMutation) OperatorNameCleared() bool {
	_, ok := m.clearedFields[userbalancelog.FieldOperatorName]
	return ok
}

// ResetOperatorName resets all changes to the "operator_name" field.
func (m *UserBalanceLogMutation) ResetOperatorName() {
	m.operator_name = nil
	delete(m.clearedFields, userbalancelog.FieldOperatorName)
}

// SetRelatedID sets the "related_id" field.
func (m *UserBalanceLogMutation) SetRelatedID(i int) {
	m.related_id = &i
	m.addrelated_id = nil
}

// RelatedID returns the value of the "related_id" field in the mutation.
func (m *UserBalanceLogMutation) RelatedID() (r int, exists bool) {
	v := m.related_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRelatedID returns the old "related_id" field's value of the UserBalanceLog entity.
// If the UserBalanceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBalanceLogMutation) OldRelatedID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelatedID: %w", err)
	}
	return oldValue.RelatedID, nil
}

// AddRelatedID adds i to the "related_id" field.
func (m *UserBalanceLogMutation) AddRelatedID(i int) {
	if m.addrelated_id != nil {
		*m.addrelated_id += i
	} else {
		m.addrelated_id = &i
	}
}

// AddedRelatedID returns the value that was added to the "related_id" field in this mutation.
func (m *UserBalanceLogMutation) AddedRelatedID() (r int, exists bool) {
	v := m.addrelated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearRelatedID clears the value of the "related_id" field.
func (m *UserBalanceLogMutation) ClearRelatedID() {
	m.related_id = nil
	m.addrelated_id = nil
	m.clearedFields[userbalancelog.FieldRelatedID] = struct{}{}
}

// RelatedIDCleared returns if the "related_id" field was cleared in this mutation.
func (m *UserBalanceLogMutation) RelatedIDCleared() bool {
	_, ok := m.clearedFields[userbalancelog.FieldRelatedID]
	return ok
}

// ResetRelatedID resets all changes to the "related_id" field.
func (m *UserBalanceLogMutation) ResetRelatedID() {
	m.related_id = nil
	m.addrelated_id = nil
	delete(m.clearedFields, userbalancelog.FieldRelatedID)
}

// SetRelatedType sets the "related_type" field.
func (m *UserBalanceLogMutation) SetRelatedType(s string) {
	m.related_type = &s
}

// RelatedType returns the value of the "related_type" field in the mutation.
func (m *UserBalanceLogMutation) RelatedType() (r string, exists bool) {
	v := m.related_type
	if v == nil {
		return
	}
	return *v, true
}

// OldRelatedType returns the old "related_type" field's value of the UserBalanceLog entity.
// If the UserBalanceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBalanceLogMutation) OldRelatedType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelatedType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelatedType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelatedType: %w", err)
	}
	return oldValue.RelatedType, nil
}

// ClearRelatedType clears the value of the "related_type" field.
func (m *UserBalanceLogMutation) ClearRelatedType() {
	m.related_type = nil
	m.clearedFields[userbalancelog.FieldRelatedType] = struct{}{}
}

// RelatedTypeCleared returns if the "related_type" field was cleared in this mutation.
func (m *UserBalanceLogMutation) RelatedTypeCleared() bool {
	_, ok := m.clearedFields[userbalancelog.FieldRelatedType]
	return ok
}

// ResetRelatedType resets all changes to the "related_type" field.
func (m *UserBalanceLogMutation) ResetRelatedType() {
	m.related_type = nil
	delete(m.clearedFields, userbalancelog.FieldRelatedType)
}

// SetIPAddress sets the "ip_address" field.
func (m *UserBalanceLogMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *UserBalanceLogMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the UserBalanceLog entity.
// If the UserBalanceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBalanceLogMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *UserBalanceLogMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[userbalancelog.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *UserBalanceLogMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[userbalancelog.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *UserBalanceLogMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, userbalancelog.FieldIPAddress)
}

// SetUserAgent sets the "user_agent" field.
func (m *UserBalanceLogMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *UserBalanceLogMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the UserBalanceLog entity.
// If the UserBalanceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBalanceLogMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *UserBalanceLogMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[userbalancelog.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *UserBalanceLogMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[userbalancelog.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *UserBalanceLogMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, userbalancelog.FieldUserAgent)
}

// Where appends a list predicates to the UserBalanceLogMutation builder.
func (m *UserBalanceLogMutation) Where(ps ...predicate.UserBalanceLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserBalanceLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserBalanceLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserBalanceLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserBalanceLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserBalanceLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserBalanceLog).
func (m *UserBalanceLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserBalanceLogMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, userbalancelog.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userbalancelog.FieldUpdatedAt)
	}
	if m.user_id != nil {
		fields = append(fields, userbalancelog.FieldUserID)
	}
	if m._type != nil {
		fields = append(fields, userbalancelog.FieldType)
	}
	if m.amount != nil {
		fields = append(fields, userbalancelog.FieldAmount)
	}
	if m.before_amount != nil {
		fields = append(fields, userbalancelog.FieldBeforeAmount)
	}
	if m.after_amount != nil {
		fields = append(fields, userbalancelog.FieldAfterAmount)
	}
	if m.reason != nil {
		fields = append(fields, userbalancelog.FieldReason)
	}
	if m.operator_id != nil {
		fields = append(fields, userbalancelog.FieldOperatorID)
	}
	if m.operator_name != nil {
		fields = append(fields, userbalancelog.FieldOperatorName)
	}
	if m.related_id != nil {
		fields = append(fields, userbalancelog.FieldRelatedID)
	}
	if m.related_type != nil {
		fields = append(fields, userbalancelog.FieldRelatedType)
	}
	if m.ip_address != nil {
		fields = append(fields, userbalancelog.FieldIPAddress)
	}
	if m.user_agent != nil {
		fields = append(fields, userbalancelog.FieldUserAgent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserBalanceLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userbalancelog.FieldCreatedAt:
		return m.CreatedAt()
	case userbalancelog.FieldUpdatedAt:
		return m.UpdatedAt()
	case userbalancelog.FieldUserID:
		return m.UserID()
	case userbalancelog.FieldType:
		return m.GetType()
	case userbalancelog.FieldAmount:
		return m.Amount()
	case userbalancelog.FieldBeforeAmount:
		return m.BeforeAmount()
	case userbalancelog.FieldAfterAmount:
		return m.AfterAmount()
	case userbalancelog.FieldReason:
		return m.Reason()
	case userbalancelog.FieldOperatorID:
		return m.OperatorID()
	case userbalancelog.FieldOperatorName:
		return m.OperatorName()
	case userbalancelog.FieldRelatedID:
		return m.RelatedID()
	case userbalancelog.FieldRelatedType:
		return m.RelatedType()
	case userbalancelog.FieldIPAddress:
		return m.IPAddress()
	case userbalancelog.FieldUserAgent:
		return m.UserAgent()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserBalanceLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userbalancelog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userbalancelog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userbalancelog.FieldUserID:
		return m.OldUserID(ctx)
	case userbalancelog.FieldType:
		return m.OldType(ctx)
	case userbalancelog.FieldAmount:
		return m.OldAmount(ctx)
	case userbalancelog.FieldBeforeAmount:
		return m.OldBeforeAmount(ctx)
	case userbalancelog.FieldAfterAmount:
		return m.OldAfterAmount(ctx)
	case userbalancelog.FieldReason:
		return m.OldReason(ctx)
	case userbalancelog.FieldOperatorID:
		return m.OldOperatorID(ctx)
	case userbalancelog.FieldOperatorName:
		return m.OldOperatorName(ctx)
	case userbalancelog.FieldRelatedID:
		return m.OldRelatedID(ctx)
	case userbalancelog.FieldRelatedType:
		return m.OldRelatedType(ctx)
	case userbalancelog.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case userbalancelog.FieldUserAgent:
		return m.OldUserAgent(ctx)
	}
	return nil, fmt.Errorf("unknown UserBalanceLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserBalanceLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userbalancelog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userbalancelog.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userbalancelog.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userbalancelog.FieldType:
		v, ok := value.(userbalancelog.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case userbalancelog.FieldAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case userbalancelog.FieldBeforeAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBeforeAmount(v)
		return nil
	case userbalancelog.FieldAfterAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAfterAmount(v)
		return nil
	case userbalancelog.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case userbalancelog.FieldOperatorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperatorID(v)
		return nil
	case userbalancelog.FieldOperatorName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperatorName(v)
		return nil
	case userbalancelog.FieldRelatedID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelatedID(v)
		return nil
	case userbalancelog.FieldRelatedType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelatedType(v)
		return nil
	case userbalancelog.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case userbalancelog.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	}
	return fmt.Errorf("unknown UserBalanceLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserBalanceLogMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, userbalancelog.FieldUserID)
	}
	if m.addamount != nil {
		fields = append(fields, userbalancelog.FieldAmount)
	}
	if m.addbefore_amount != nil {
		fields = append(fields, userbalancelog.FieldBeforeAmount)
	}
	if m.addafter_amount != nil {
		fields = append(fields, userbalancelog.FieldAfterAmount)
	}
	if m.addoperator_id != nil {
		fields = append(fields, userbalancelog.FieldOperatorID)
	}
	if m.addrelated_id != nil {
		fields = append(fields, userbalancelog.FieldRelatedID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserBalanceLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userbalancelog.FieldUserID:
		return m.AddedUserID()
	case userbalancelog.FieldAmount:
		return m.AddedAmount()
	case userbalancelog.FieldBeforeAmount:
		return m.AddedBeforeAmount()
	case userbalancelog.FieldAfterAmount:
		return m.AddedAfterAmount()
	case userbalancelog.FieldOperatorID:
		return m.AddedOperatorID()
	case userbalancelog.FieldRelatedID:
		return m.AddedRelatedID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserBalanceLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userbalancelog.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case userbalancelog.FieldAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case userbalancelog.FieldBeforeAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBeforeAmount(v)
		return nil
	case userbalancelog.FieldAfterAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAfterAmount(v)
		return nil
	case userbalancelog.FieldOperatorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOperatorID(v)
		return nil
	case userbalancelog.FieldRelatedID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRelatedID(v)
		return nil
	}
	return fmt.Errorf("unknown UserBalanceLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserBalanceLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userbalancelog.FieldOperatorID) {
		fields = append(fields, userbalancelog.FieldOperatorID)
	}
	if m.FieldCleared(userbalancelog.FieldOperatorName) {
		fields = append(fields, userbalancelog.FieldOperatorName)
	}
	if m.FieldCleared(userbalancelog.FieldRelatedID) {
		fields = append(fields, userbalancelog.FieldRelatedID)
	}
	if m.FieldCleared(userbalancelog.FieldRelatedType) {
		fields = append(fields, userbalancelog.FieldRelatedType)
	}
	if m.FieldCleared(userbalancelog.FieldIPAddress) {
		fields = append(fields, userbalancelog.FieldIPAddress)
	}
	if m.FieldCleared(userbalancelog.FieldUserAgent) {
		fields = append(fields, userbalancelog.FieldUserAgent)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserBalanceLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserBalanceLogMutation) ClearField(name string) error {
	switch name {
	case userbalancelog.FieldOperatorID:
		m.ClearOperatorID()
		return nil
	case userbalancelog.FieldOperatorName:
		m.ClearOperatorName()
		return nil
	case userbalancelog.FieldRelatedID:
		m.ClearRelatedID()
		return nil
	case userbalancelog.FieldRelatedType:
		m.ClearRelatedType()
		return nil
	case userbalancelog.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case userbalancelog.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	}
	return fmt.Errorf("unknown UserBalanceLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserBalanceLogMutation) ResetField(name string) error {
	switch name {
	case userbalancelog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userbalancelog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userbalancelog.FieldUserID:
		m.ResetUserID()
		return nil
	case userbalancelog.FieldType:
		m.ResetType()
		return nil
	case userbalancelog.FieldAmount:
		m.ResetAmount()
		return nil
	case userbalancelog.FieldBeforeAmount:
		m.ResetBeforeAmount()
		return nil
	case userbalancelog.FieldAfterAmount:
		m.ResetAfterAmount()
		return nil
	case userbalancelog.FieldReason:
		m.ResetReason()
		return nil
	case userbalancelog.FieldOperatorID:
		m.ResetOperatorID()
		return nil
	case userbalancelog.FieldOperatorName:
		m.ResetOperatorName()
		return nil
	case userbalancelog.FieldRelatedID:
		m.ResetRelatedID()
		return nil
	case userbalancelog.FieldRelatedType:
		m.ResetRelatedType()
		return nil
	case userbalancelog.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case userbalancelog.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	}
	return fmt.Errorf("unknown UserBalanceLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserBalanceLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserBalanceLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserBalanceLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserBalanceLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserBalanceLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserBalanceLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserBalanceLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserBalanceLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserBalanceLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserBalanceLog edge %s", name)
}

// UserLoginLogMutation represents an operation that mutates the UserLoginLog nodes in the graph.
type UserLoginLogMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	user_id       *int
	adduser_id    *int
	ip_address    *string
	ip_country    *string
	ip_city       *string
	success       *bool
	device_info   *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UserLoginLog, error)
	predicates    []predicate.UserLoginLog
}

var _ ent.Mutation = (*UserLoginLogMutation)(nil)

// userloginlogOption allows management of the mutation configuration using functional options.
type userloginlogOption func(*UserLoginLogMutation)

// newUserLoginLogMutation creates new mutation for the UserLoginLog entity.
func newUserLoginLogMutation(c config, op Op, opts ...userloginlogOption) *UserLoginLogMutation {
	m := &UserLoginLogMutation{
		config:        c,
		op:            op,
		typ:           TypeUserLoginLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserLoginLogID sets the ID field of the mutation.
func withUserLoginLogID(id int) userloginlogOption {
	return func(m *UserLoginLogMutation) {
		var (
			err   error
			once  sync.Once
			value *UserLoginLog
		)
		m.oldValue = func(ctx context.Context) (*UserLoginLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserLoginLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserLoginLog sets the old UserLoginLog of the mutation.
func withUserLoginLog(node *UserLoginLog) userloginlogOption {
	return func(m *UserLoginLogMutation) {
		m.oldValue = func(context.Context) (*UserLoginLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserLoginLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserLoginLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserLoginLog entities.
func (m *UserLoginLogMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserLoginLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserLoginLogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserLoginLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserLoginLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserLoginLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserLoginLog entity.
// If the UserLoginLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserLoginLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserLoginLogMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserLoginLogMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserLoginLog entity.
// If the UserLoginLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginLogMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserLoginLogMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *UserLoginLogMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserLoginLogMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserLoginLog entity.
// If the UserLoginLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginLogMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *UserLoginLogMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *UserLoginLogMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserLoginLogMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetIPAddress sets the "ip_address" field.
func (m *UserLoginLogMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *UserLoginLogMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the UserLoginLog entity.
// If the UserLoginLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginLogMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *UserLoginLogMutation) ResetIPAddress() {
	m.ip_address = nil
}

// SetIPCountry sets the "ip_country" field.
func (m *UserLoginLogMutation) SetIPCountry(s string) {
	m.ip_country = &s
}

// IPCountry returns the value of the "ip_country" field in the mutation.
func (m *UserLoginLogMutation) IPCountry() (r string, exists bool) {
	v := m.ip_country
	if v == nil {
		return
	}
	return *v, true
}

// OldIPCountry returns the old "ip_country" field's value of the UserLoginLog entity.
// If the UserLoginLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginLogMutation) OldIPCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPCountry: %w", err)
	}
	return oldValue.IPCountry, nil
}

// ClearIPCountry clears the value of the "ip_country" field.
func (m *UserLoginLogMutation) ClearIPCountry() {
	m.ip_country = nil
	m.clearedFields[userloginlog.FieldIPCountry] = struct{}{}
}

// IPCountryCleared returns if the "ip_country" field was cleared in this mutation.
func (m *UserLoginLogMutation) IPCountryCleared() bool {
	_, ok := m.clearedFields[userloginlog.FieldIPCountry]
	return ok
}

// ResetIPCountry resets all changes to the "ip_country" field.
func (m *UserLoginLogMutation) ResetIPCountry() {
	m.ip_country = nil
	delete(m.clearedFields, userloginlog.FieldIPCountry)
}

// SetIPCity sets the "ip_city" field.
func (m *UserLoginLogMutation) SetIPCity(s string) {
	m.ip_city = &s
}

// IPCity returns the value of the "ip_city" field in the mutation.
func (m *UserLoginLogMutation) IPCity() (r string, exists bool) {
	v := m.ip_city
	if v == nil {
		return
	}
	return *v, true
}

// OldIPCity returns the old "ip_city" field's value of the UserLoginLog entity.
// If the UserLoginLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginLogMutation) OldIPCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPCity: %w", err)
	}
	return oldValue.IPCity, nil
}

// ClearIPCity clears the value of the "ip_city" field.
func (m *UserLoginLogMutation) ClearIPCity() {
	m.ip_city = nil
	m.clearedFields[userloginlog.FieldIPCity] = struct{}{}
}

// IPCityCleared returns if the "ip_city" field was cleared in this mutation.
func (m *UserLoginLogMutation) IPCityCleared() bool {
	_, ok := m.clearedFields[userloginlog.FieldIPCity]
	return ok
}

// ResetIPCity resets all changes to the "ip_city" field.
func (m *UserLoginLogMutation) ResetIPCity() {
	m.ip_city = nil
	delete(m.clearedFields, userloginlog.FieldIPCity)
}

// SetSuccess sets the "success" field.
func (m *UserLoginLogMutation) SetSuccess(b bool) {
	m.success = &b
}

// Success returns the value of the "success" field in the mutation.
func (m *UserLoginLogMutation) Success() (r bool, exists bool) {
	v := m.success
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccess returns the old "success" field's value of the UserLoginLog entity.
// If the UserLoginLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginLogMutation) OldSuccess(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccess: %w", err)
	}
	return oldValue.Success, nil
}

// ResetSuccess resets all changes to the "success" field.
func (m *UserLoginLogMutation) ResetSuccess() {
	m.success = nil
}

// SetDeviceInfo sets the "device_info" field.
func (m *UserLoginLogMutation) SetDeviceInfo(s string) {
	m.device_info = &s
}

// DeviceInfo returns the value of the "device_info" field in the mutation.
func (m *UserLoginLogMutation) DeviceInfo() (r string, exists bool) {
	v := m.device_info
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceInfo returns the old "device_info" field's value of the UserLoginLog entity.
// If the UserLoginLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginLogMutation) OldDeviceInfo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceInfo: %w", err)
	}
	return oldValue.DeviceInfo, nil
}

// ClearDeviceInfo clears the value of the "device_info" field.
func (m *UserLoginLogMutation) ClearDeviceInfo() {
	m.device_info = nil
	m.clearedFields[userloginlog.FieldDeviceInfo] = struct{}{}
}

// DeviceInfoCleared returns if the "device_info" field was cleared in this mutation.
func (m *UserLoginLogMutation) DeviceInfoCleared() bool {
	_, ok := m.clearedFields[userloginlog.FieldDeviceInfo]
	return ok
}

// ResetDeviceInfo resets all changes to the "device_info" field.
func (m *UserLoginLogMutation) ResetDeviceInfo() {
	m.device_info = nil
	delete(m.clearedFields, userloginlog.FieldDeviceInfo)
}

// Where appends a list predicates to the UserLoginLogMutation builder.
func (m *UserLoginLogMutation) Where(ps ...predicate.UserLoginLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserLoginLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserLoginLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserLoginLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserLoginLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserLoginLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserLoginLog).
func (m *UserLoginLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserLoginLogMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, userloginlog.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userloginlog.FieldUpdatedAt)
	}
	if m.user_id != nil {
		fields = append(fields, userloginlog.FieldUserID)
	}
	if m.ip_address != nil {
		fields = append(fields, userloginlog.FieldIPAddress)
	}
	if m.ip_country != nil {
		fields = append(fields, userloginlog.FieldIPCountry)
	}
	if m.ip_city != nil {
		fields = append(fields, userloginlog.FieldIPCity)
	}
	if m.success != nil {
		fields = append(fields, userloginlog.FieldSuccess)
	}
	if m.device_info != nil {
		fields = append(fields, userloginlog.FieldDeviceInfo)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserLoginLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userloginlog.FieldCreatedAt:
		return m.CreatedAt()
	case userloginlog.FieldUpdatedAt:
		return m.UpdatedAt()
	case userloginlog.FieldUserID:
		return m.UserID()
	case userloginlog.FieldIPAddress:
		return m.IPAddress()
	case userloginlog.FieldIPCountry:
		return m.IPCountry()
	case userloginlog.FieldIPCity:
		return m.IPCity()
	case userloginlog.FieldSuccess:
		return m.Success()
	case userloginlog.FieldDeviceInfo:
		return m.DeviceInfo()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserLoginLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userloginlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userloginlog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userloginlog.FieldUserID:
		return m.OldUserID(ctx)
	case userloginlog.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case userloginlog.FieldIPCountry:
		return m.OldIPCountry(ctx)
	case userloginlog.FieldIPCity:
		return m.OldIPCity(ctx)
	case userloginlog.FieldSuccess:
		return m.OldSuccess(ctx)
	case userloginlog.FieldDeviceInfo:
		return m.OldDeviceInfo(ctx)
	}
	return nil, fmt.Errorf("unknown UserLoginLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserLoginLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userloginlog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userloginlog.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userloginlog.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userloginlog.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case userloginlog.FieldIPCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPCountry(v)
		return nil
	case userloginlog.FieldIPCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPCity(v)
		return nil
	case userloginlog.FieldSuccess:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccess(v)
		return nil
	case userloginlog.FieldDeviceInfo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceInfo(v)
		return nil
	}
	return fmt.Errorf("unknown UserLoginLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserLoginLogMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, userloginlog.FieldUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserLoginLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userloginlog.FieldUserID:
		return m.AddedUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserLoginLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userloginlog.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	}
	return fmt.Errorf("unknown UserLoginLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserLoginLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userloginlog.FieldIPCountry) {
		fields = append(fields, userloginlog.FieldIPCountry)
	}
	if m.FieldCleared(userloginlog.FieldIPCity) {
		fields = append(fields, userloginlog.FieldIPCity)
	}
	if m.FieldCleared(userloginlog.FieldDeviceInfo) {
		fields = append(fields, userloginlog.FieldDeviceInfo)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserLoginLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserLoginLogMutation) ClearField(name string) error {
	switch name {
	case userloginlog.FieldIPCountry:
		m.ClearIPCountry()
		return nil
	case userloginlog.FieldIPCity:
		m.ClearIPCity()
		return nil
	case userloginlog.FieldDeviceInfo:
		m.ClearDeviceInfo()
		return nil
	}
	return fmt.Errorf("unknown UserLoginLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserLoginLogMutation) ResetField(name string) error {
	switch name {
	case userloginlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userloginlog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userloginlog.FieldUserID:
		m.ResetUserID()
		return nil
	case userloginlog.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case userloginlog.FieldIPCountry:
		m.ResetIPCountry()
		return nil
	case userloginlog.FieldIPCity:
		m.ResetIPCity()
		return nil
	case userloginlog.FieldSuccess:
		m.ResetSuccess()
		return nil
	case userloginlog.FieldDeviceInfo:
		m.ResetDeviceInfo()
		return nil
	}
	return fmt.Errorf("unknown UserLoginLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserLoginLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserLoginLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserLoginLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserLoginLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserLoginLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserLoginLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserLoginLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserLoginLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserLoginLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserLoginLog edge %s", name)
}

// UserOAuthMutation represents an operation that mutates the UserOAuth nodes in the graph.
type UserOAuthMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	user_id           *int
	adduser_id        *int
	provider          *useroauth.Provider
	provider_user_id  *string
	provider_username *string
	provider_email    *string
	provider_avatar   *string
	extra_data        *map[string]interface{}
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*UserOAuth, error)
	predicates        []predicate.UserOAuth
}

var _ ent.Mutation = (*UserOAuthMutation)(nil)

// useroauthOption allows management of the mutation configuration using functional options.
type useroauthOption func(*UserOAuthMutation)

// newUserOAuthMutation creates new mutation for the UserOAuth entity.
func newUserOAuthMutation(c config, op Op, opts ...useroauthOption) *UserOAuthMutation {
	m := &UserOAuthMutation{
		config:        c,
		op:            op,
		typ:           TypeUserOAuth,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserOAuthID sets the ID field of the mutation.
func withUserOAuthID(id int) useroauthOption {
	return func(m *UserOAuthMutation) {
		var (
			err   error
			once  sync.Once
			value *UserOAuth
		)
		m.oldValue = func(ctx context.Context) (*UserOAuth, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserOAuth.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserOAuth sets the old UserOAuth of the mutation.
func withUserOAuth(node *UserOAuth) useroauthOption {
	return func(m *UserOAuthMutation) {
		m.oldValue = func(context.Context) (*UserOAuth, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserOAuthMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserOAuthMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserOAuth entities.
func (m *UserOAuthMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserOAuthMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserOAuthMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserOAuth.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserOAuthMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserOAuthMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserOAuth entity.
// If the UserOAuth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserOAuthMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserOAuthMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserOAuthMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserOAuthMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserOAuth entity.
// If the UserOAuth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserOAuthMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserOAuthMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *UserOAuthMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserOAuthMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserOAuth entity.
// If the UserOAuth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserOAuthMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *UserOAuthMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *UserOAuthMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserOAuthMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetProvider sets the "provider" field.
func (m *UserOAuthMutation) SetProvider(u useroauth.Provider) {
	m.provider = &u
}

// Provider returns the value of the "provider" field in the mutation.
func (m *UserOAuthMutation) Provider() (r useroauth.Provider, exists bool) {
	v := m.provider
	if v == nil {
		return
	}
	return *v, true
}

// OldProvider returns the old "provider" field's value of the UserOAuth entity.
// If the UserOAuth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserOAuthMutation) OldProvider(ctx context.Context) (v useroauth.Provider, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvider: %w", err)
	}
	return oldValue.Provider, nil
}

// ResetProvider resets all changes to the "provider" field.
func (m *UserOAuthMutation) ResetProvider() {
	m.provider = nil
}

// SetProviderUserID sets the "provider_user_id" field.
func (m *UserOAuthMutation) SetProviderUserID(s string) {
	m.provider_user_id = &s
}

// ProviderUserID returns the value of the "provider_user_id" field in the mutation.
func (m *UserOAuthMutation) ProviderUserID() (r string, exists bool) {
	v := m.provider_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderUserID returns the old "provider_user_id" field's value of the UserOAuth entity.
// If the UserOAuth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserOAuthMutation) OldProviderUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderUserID: %w", err)
	}
	return oldValue.ProviderUserID, nil
}

// ResetProviderUserID resets all changes to the "provider_user_id" field.
func (m *UserOAuthMutation) ResetProviderUserID() {
	m.provider_user_id = nil
}

// SetProviderUsername sets the "provider_username" field.
func (m *UserOAuthMutation) SetProviderUsername(s string) {
	m.provider_username = &s
}

// ProviderUsername returns the value of the "provider_username" field in the mutation.
func (m *UserOAuthMutation) ProviderUsername() (r string, exists bool) {
	v := m.provider_username
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderUsername returns the old "provider_username" field's value of the UserOAuth entity.
// If the UserOAuth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserOAuthMutation) OldProviderUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderUsername: %w", err)
	}
	return oldValue.ProviderUsername, nil
}

// ClearProviderUsername clears the value of the "provider_username" field.
func (m *UserOAuthMutation) ClearProviderUsername() {
	m.provider_username = nil
	m.clearedFields[useroauth.FieldProviderUsername] = struct{}{}
}

// ProviderUsernameCleared returns if the "provider_username" field was cleared in this mutation.
func (m *UserOAuthMutation) ProviderUsernameCleared() bool {
	_, ok := m.clearedFields[useroauth.FieldProviderUsername]
	return ok
}

// ResetProviderUsername resets all changes to the "provider_username" field.
func (m *UserOAuthMutation) ResetProviderUsername() {
	m.provider_username = nil
	delete(m.clearedFields, useroauth.FieldProviderUsername)
}

// SetProviderEmail sets the "provider_email" field.
func (m *UserOAuthMutation) SetProviderEmail(s string) {
	m.provider_email = &s
}

// ProviderEmail returns the value of the "provider_email" field in the mutation.
func (m *UserOAuthMutation) ProviderEmail() (r string, exists bool) {
	v := m.provider_email
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderEmail returns the old "provider_email" field's value of the UserOAuth entity.
// If the UserOAuth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserOAuthMutation) OldProviderEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderEmail: %w", err)
	}
	return oldValue.ProviderEmail, nil
}

// ClearProviderEmail clears the value of the "provider_email" field.
func (m *UserOAuthMutation) ClearProviderEmail() {
	m.provider_email = nil
	m.clearedFields[useroauth.FieldProviderEmail] = struct{}{}
}

// ProviderEmailCleared returns if the "provider_email" field was cleared in this mutation.
func (m *UserOAuthMutation) ProviderEmailCleared() bool {
	_, ok := m.clearedFields[useroauth.FieldProviderEmail]
	return ok
}

// ResetProviderEmail resets all changes to the "provider_email" field.
func (m *UserOAuthMutation) ResetProviderEmail() {
	m.provider_email = nil
	delete(m.clearedFields, useroauth.FieldProviderEmail)
}

// SetProviderAvatar sets the "provider_avatar" field.
func (m *UserOAuthMutation) SetProviderAvatar(s string) {
	m.provider_avatar = &s
}

// ProviderAvatar returns the value of the "provider_avatar" field in the mutation.
func (m *UserOAuthMutation) ProviderAvatar() (r string, exists bool) {
	v := m.provider_avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderAvatar returns the old "provider_avatar" field's value of the UserOAuth entity.
// If the UserOAuth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserOAuthMutation) OldProviderAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderAvatar: %w", err)
	}
	return oldValue.ProviderAvatar, nil
}

// ClearProviderAvatar clears the value of the "provider_avatar" field.
func (m *UserOAuthMutation) ClearProviderAvatar() {
	m.provider_avatar = nil
	m.clearedFields[useroauth.FieldProviderAvatar] = struct{}{}
}

// ProviderAvatarCleared returns if the "provider_avatar" field was cleared in this mutation.
func (m *UserOAuthMutation) ProviderAvatarCleared() bool {
	_, ok := m.clearedFields[useroauth.FieldProviderAvatar]
	return ok
}

// ResetProviderAvatar resets all changes to the "provider_avatar" field.
func (m *UserOAuthMutation) ResetProviderAvatar() {
	m.provider_avatar = nil
	delete(m.clearedFields, useroauth.FieldProviderAvatar)
}

// SetExtraData sets the "extra_data" field.
func (m *UserOAuthMutation) SetExtraData(value map[string]interface{}) {
	m.extra_data = &value
}

// ExtraData returns the value of the "extra_data" field in the mutation.
func (m *UserOAuthMutation) ExtraData() (r map[string]interface{}, exists bool) {
	v := m.extra_data
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraData returns the old "extra_data" field's value of the UserOAuth entity.
// If the UserOAuth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserOAuthMutation) OldExtraData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraData: %w", err)
	}
	return oldValue.ExtraData, nil
}

// ClearExtraData clears the value of the "extra_data" field.
func (m *UserOAuthMutation) ClearExtraData() {
	m.extra_data = nil
	m.clearedFields[useroauth.FieldExtraData] = struct{}{}
}

// ExtraDataCleared returns if the "extra_data" field was cleared in this mutation.
func (m *UserOAuthMutation) ExtraDataCleared() bool {
	_, ok := m.clearedFields[useroauth.FieldExtraData]
	return ok
}

// ResetExtraData resets all changes to the "extra_data" field.
func (m *UserOAuthMutation) ResetExtraData() {
	m.extra_data = nil
	delete(m.clearedFields, useroauth.FieldExtraData)
}

// Where appends a list predicates to the UserOAuthMutation builder.
func (m *UserOAuthMutation) Where(ps ...predicate.UserOAuth) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserOAuthMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserOAuthMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserOAuth, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserOAuthMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserOAuthMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserOAuth).
func (m *UserOAuthMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserOAuthMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, useroauth.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, useroauth.FieldUpdatedAt)
	}
	if m.user_id != nil {
		fields = append(fields, useroauth.FieldUserID)
	}
	if m.provider != nil {
		fields = append(fields, useroauth.FieldProvider)
	}
	if m.provider_user_id != nil {
		fields = append(fields, useroauth.FieldProviderUserID)
	}
	if m.provider_username != nil {
		fields = append(fields, useroauth.FieldProviderUsername)
	}
	if m.provider_email != nil {
		fields = append(fields, useroauth.FieldProviderEmail)
	}
	if m.provider_avatar != nil {
		fields = append(fields, useroauth.FieldProviderAvatar)
	}
	if m.extra_data != nil {
		fields = append(fields, useroauth.FieldExtraData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserOAuthMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case useroauth.FieldCreatedAt:
		return m.CreatedAt()
	case useroauth.FieldUpdatedAt:
		return m.UpdatedAt()
	case useroauth.FieldUserID:
		return m.UserID()
	case useroauth.FieldProvider:
		return m.Provider()
	case useroauth.FieldProviderUserID:
		return m.ProviderUserID()
	case useroauth.FieldProviderUsername:
		return m.ProviderUsername()
	case useroauth.FieldProviderEmail:
		return m.ProviderEmail()
	case useroauth.FieldProviderAvatar:
		return m.ProviderAvatar()
	case useroauth.FieldExtraData:
		return m.ExtraData()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserOAuthMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case useroauth.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case useroauth.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case useroauth.FieldUserID:
		return m.OldUserID(ctx)
	case useroauth.FieldProvider:
		return m.OldProvider(ctx)
	case useroauth.FieldProviderUserID:
		return m.OldProviderUserID(ctx)
	case useroauth.FieldProviderUsername:
		return m.OldProviderUsername(ctx)
	case useroauth.FieldProviderEmail:
		return m.OldProviderEmail(ctx)
	case useroauth.FieldProviderAvatar:
		return m.OldProviderAvatar(ctx)
	case useroauth.FieldExtraData:
		return m.OldExtraData(ctx)
	}
	return nil, fmt.Errorf("unknown UserOAuth field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserOAuthMutation) SetField(name string, value ent.Value) error {
	switch name {
	case useroauth.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case useroauth.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case useroauth.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case useroauth.FieldProvider:
		v, ok := value.(useroauth.Provider)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvider(v)
		return nil
	case useroauth.FieldProviderUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderUserID(v)
		return nil
	case useroauth.FieldProviderUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderUsername(v)
		return nil
	case useroauth.FieldProviderEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderEmail(v)
		return nil
	case useroauth.FieldProviderAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderAvatar(v)
		return nil
	case useroauth.FieldExtraData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraData(v)
		return nil
	}
	return fmt.Errorf("unknown UserOAuth field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserOAuthMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, useroauth.FieldUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserOAuthMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case useroauth.FieldUserID:
		return m.AddedUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserOAuthMutation) AddField(name string, value ent.Value) error {
	switch name {
	case useroauth.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	}
	return fmt.Errorf("unknown UserOAuth numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserOAuthMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(useroauth.FieldProviderUsername) {
		fields = append(fields, useroauth.FieldProviderUsername)
	}
	if m.FieldCleared(useroauth.FieldProviderEmail) {
		fields = append(fields, useroauth.FieldProviderEmail)
	}
	if m.FieldCleared(useroauth.FieldProviderAvatar) {
		fields = append(fields, useroauth.FieldProviderAvatar)
	}
	if m.FieldCleared(useroauth.FieldExtraData) {
		fields = append(fields, useroauth.FieldExtraData)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserOAuthMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserOAuthMutation) ClearField(name string) error {
	switch name {
	case useroauth.FieldProviderUsername:
		m.ClearProviderUsername()
		return nil
	case useroauth.FieldProviderEmail:
		m.ClearProviderEmail()
		return nil
	case useroauth.FieldProviderAvatar:
		m.ClearProviderAvatar()
		return nil
	case useroauth.FieldExtraData:
		m.ClearExtraData()
		return nil
	}
	return fmt.Errorf("unknown UserOAuth nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserOAuthMutation) ResetField(name string) error {
	switch name {
	case useroauth.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case useroauth.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case useroauth.FieldUserID:
		m.ResetUserID()
		return nil
	case useroauth.FieldProvider:
		m.ResetProvider()
		return nil
	case useroauth.FieldProviderUserID:
		m.ResetProviderUserID()
		return nil
	case useroauth.FieldProviderUsername:
		m.ResetProviderUsername()
		return nil
	case useroauth.FieldProviderEmail:
		m.ResetProviderEmail()
		return nil
	case useroauth.FieldProviderAvatar:
		m.ResetProviderAvatar()
		return nil
	case useroauth.FieldExtraData:
		m.ResetExtraData()
		return nil
	}
	return fmt.Errorf("unknown UserOAuth field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserOAuthMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserOAuthMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserOAuthMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserOAuthMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserOAuthMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserOAuthMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserOAuthMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserOAuth unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserOAuthMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserOAuth edge %s", name)
}
