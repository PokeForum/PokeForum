// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/PokeForum/PokeForum/ent/category"
	"github.com/PokeForum/PokeForum/ent/comment"
	"github.com/PokeForum/PokeForum/ent/commentaction"
	"github.com/PokeForum/PokeForum/ent/post"
	"github.com/PokeForum/PokeForum/ent/postaction"
	"github.com/PokeForum/PokeForum/ent/predicate"
	"github.com/PokeForum/PokeForum/ent/settings"
	"github.com/PokeForum/PokeForum/ent/user"
	"github.com/PokeForum/PokeForum/ent/userbalancelog"
	"github.com/PokeForum/PokeForum/ent/userloginlog"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCategory       = "Category"
	TypeComment        = "Comment"
	TypeCommentAction  = "CommentAction"
	TypePost           = "Post"
	TypePostAction     = "PostAction"
	TypeSettings       = "Settings"
	TypeUser           = "User"
	TypeUserBalanceLog = "UserBalanceLog"
	TypeUserLoginLog   = "UserLoginLog"
)

// CategoryMutation represents an operation that mutates the Category nodes in the graph.
type CategoryMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	name              *string
	slug              *string
	description       *string
	icon              *string
	weight            *int
	addweight         *int
	status            *category.Status
	clearedFields     map[string]struct{}
	moderators        map[int]struct{}
	removedmoderators map[int]struct{}
	clearedmoderators bool
	done              bool
	oldValue          func(context.Context) (*Category, error)
	predicates        []predicate.Category
}

var _ ent.Mutation = (*CategoryMutation)(nil)

// categoryOption allows management of the mutation configuration using functional options.
type categoryOption func(*CategoryMutation)

// newCategoryMutation creates new mutation for the Category entity.
func newCategoryMutation(c config, op Op, opts ...categoryOption) *CategoryMutation {
	m := &CategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCategoryID sets the ID field of the mutation.
func withCategoryID(id int) categoryOption {
	return func(m *CategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Category
		)
		m.oldValue = func(ctx context.Context) (*Category, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Category.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCategory sets the old Category of the mutation.
func withCategory(node *Category) categoryOption {
	return func(m *CategoryMutation) {
		m.oldValue = func(context.Context) (*Category, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Category entities.
func (m *CategoryMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CategoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Category.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *CategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CategoryMutation) ResetName() {
	m.name = nil
}

// SetSlug sets the "slug" field.
func (m *CategoryMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *CategoryMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *CategoryMutation) ResetSlug() {
	m.slug = nil
}

// SetDescription sets the "description" field.
func (m *CategoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CategoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CategoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[category.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CategoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[category.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CategoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, category.FieldDescription)
}

// SetIcon sets the "icon" field.
func (m *CategoryMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *CategoryMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *CategoryMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[category.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *CategoryMutation) IconCleared() bool {
	_, ok := m.clearedFields[category.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *CategoryMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, category.FieldIcon)
}

// SetWeight sets the "weight" field.
func (m *CategoryMutation) SetWeight(i int) {
	m.weight = &i
	m.addweight = nil
}

// Weight returns the value of the "weight" field in the mutation.
func (m *CategoryMutation) Weight() (r int, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old "weight" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldWeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// AddWeight adds i to the "weight" field.
func (m *CategoryMutation) AddWeight(i int) {
	if m.addweight != nil {
		*m.addweight += i
	} else {
		m.addweight = &i
	}
}

// AddedWeight returns the value that was added to the "weight" field in this mutation.
func (m *CategoryMutation) AddedWeight() (r int, exists bool) {
	v := m.addweight
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeight resets all changes to the "weight" field.
func (m *CategoryMutation) ResetWeight() {
	m.weight = nil
	m.addweight = nil
}

// SetStatus sets the "status" field.
func (m *CategoryMutation) SetStatus(c category.Status) {
	m.status = &c
}

// Status returns the value of the "status" field in the mutation.
func (m *CategoryMutation) Status() (r category.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldStatus(ctx context.Context) (v category.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CategoryMutation) ResetStatus() {
	m.status = nil
}

// AddModeratorIDs adds the "moderators" edge to the User entity by ids.
func (m *CategoryMutation) AddModeratorIDs(ids ...int) {
	if m.moderators == nil {
		m.moderators = make(map[int]struct{})
	}
	for i := range ids {
		m.moderators[ids[i]] = struct{}{}
	}
}

// ClearModerators clears the "moderators" edge to the User entity.
func (m *CategoryMutation) ClearModerators() {
	m.clearedmoderators = true
}

// ModeratorsCleared reports if the "moderators" edge to the User entity was cleared.
func (m *CategoryMutation) ModeratorsCleared() bool {
	return m.clearedmoderators
}

// RemoveModeratorIDs removes the "moderators" edge to the User entity by IDs.
func (m *CategoryMutation) RemoveModeratorIDs(ids ...int) {
	if m.removedmoderators == nil {
		m.removedmoderators = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.moderators, ids[i])
		m.removedmoderators[ids[i]] = struct{}{}
	}
}

// RemovedModerators returns the removed IDs of the "moderators" edge to the User entity.
func (m *CategoryMutation) RemovedModeratorsIDs() (ids []int) {
	for id := range m.removedmoderators {
		ids = append(ids, id)
	}
	return
}

// ModeratorsIDs returns the "moderators" edge IDs in the mutation.
func (m *CategoryMutation) ModeratorsIDs() (ids []int) {
	for id := range m.moderators {
		ids = append(ids, id)
	}
	return
}

// ResetModerators resets all changes to the "moderators" edge.
func (m *CategoryMutation) ResetModerators() {
	m.moderators = nil
	m.clearedmoderators = false
	m.removedmoderators = nil
}

// Where appends a list predicates to the CategoryMutation builder.
func (m *CategoryMutation) Where(ps ...predicate.Category) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Category, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Category).
func (m *CategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CategoryMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, category.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, category.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, category.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, category.FieldSlug)
	}
	if m.description != nil {
		fields = append(fields, category.FieldDescription)
	}
	if m.icon != nil {
		fields = append(fields, category.FieldIcon)
	}
	if m.weight != nil {
		fields = append(fields, category.FieldWeight)
	}
	if m.status != nil {
		fields = append(fields, category.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case category.FieldCreatedAt:
		return m.CreatedAt()
	case category.FieldUpdatedAt:
		return m.UpdatedAt()
	case category.FieldName:
		return m.Name()
	case category.FieldSlug:
		return m.Slug()
	case category.FieldDescription:
		return m.Description()
	case category.FieldIcon:
		return m.Icon()
	case category.FieldWeight:
		return m.Weight()
	case category.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case category.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case category.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case category.FieldName:
		return m.OldName(ctx)
	case category.FieldSlug:
		return m.OldSlug(ctx)
	case category.FieldDescription:
		return m.OldDescription(ctx)
	case category.FieldIcon:
		return m.OldIcon(ctx)
	case category.FieldWeight:
		return m.OldWeight(ctx)
	case category.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Category field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case category.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case category.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case category.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case category.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case category.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case category.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case category.FieldWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	case category.FieldStatus:
		v, ok := value.(category.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CategoryMutation) AddedFields() []string {
	var fields []string
	if m.addweight != nil {
		fields = append(fields, category.FieldWeight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case category.FieldWeight:
		return m.AddedWeight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case category.FieldWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeight(v)
		return nil
	}
	return fmt.Errorf("unknown Category numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(category.FieldDescription) {
		fields = append(fields, category.FieldDescription)
	}
	if m.FieldCleared(category.FieldIcon) {
		fields = append(fields, category.FieldIcon)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CategoryMutation) ClearField(name string) error {
	switch name {
	case category.FieldDescription:
		m.ClearDescription()
		return nil
	case category.FieldIcon:
		m.ClearIcon()
		return nil
	}
	return fmt.Errorf("unknown Category nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CategoryMutation) ResetField(name string) error {
	switch name {
	case category.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case category.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case category.FieldName:
		m.ResetName()
		return nil
	case category.FieldSlug:
		m.ResetSlug()
		return nil
	case category.FieldDescription:
		m.ResetDescription()
		return nil
	case category.FieldIcon:
		m.ResetIcon()
		return nil
	case category.FieldWeight:
		m.ResetWeight()
		return nil
	case category.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.moderators != nil {
		edges = append(edges, category.EdgeModerators)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeModerators:
		ids := make([]ent.Value, 0, len(m.moderators))
		for id := range m.moderators {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedmoderators != nil {
		edges = append(edges, category.EdgeModerators)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeModerators:
		ids := make([]ent.Value, 0, len(m.removedmoderators))
		for id := range m.removedmoderators {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmoderators {
		edges = append(edges, category.EdgeModerators)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case category.EdgeModerators:
		return m.clearedmoderators
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CategoryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Category unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CategoryMutation) ResetEdge(name string) error {
	switch name {
	case category.EdgeModerators:
		m.ResetModerators()
		return nil
	}
	return fmt.Errorf("unknown Category edge %s", name)
}

// CommentMutation represents an operation that mutates the Comment nodes in the graph.
type CommentMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	updated_at           *time.Time
	content              *string
	like_count           *int
	addlike_count        *int
	dislike_count        *int
	adddislike_count     *int
	is_selected          *bool
	is_pinned            *bool
	commenter_ip         *string
	device_info          *string
	clearedFields        map[string]struct{}
	post                 *int
	clearedpost          bool
	author               *int
	clearedauthor        bool
	parent               *int
	clearedparent        bool
	reply_to_user        *int
	clearedreply_to_user bool
	done                 bool
	oldValue             func(context.Context) (*Comment, error)
	predicates           []predicate.Comment
}

var _ ent.Mutation = (*CommentMutation)(nil)

// commentOption allows management of the mutation configuration using functional options.
type commentOption func(*CommentMutation)

// newCommentMutation creates new mutation for the Comment entity.
func newCommentMutation(c config, op Op, opts ...commentOption) *CommentMutation {
	m := &CommentMutation{
		config:        c,
		op:            op,
		typ:           TypeComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommentID sets the ID field of the mutation.
func withCommentID(id int) commentOption {
	return func(m *CommentMutation) {
		var (
			err   error
			once  sync.Once
			value *Comment
		)
		m.oldValue = func(ctx context.Context) (*Comment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Comment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withComment sets the old Comment of the mutation.
func withComment(node *Comment) commentOption {
	return func(m *CommentMutation) {
		m.oldValue = func(context.Context) (*Comment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Comment entities.
func (m *CommentMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Comment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CommentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CommentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CommentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CommentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CommentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CommentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetPostID sets the "post_id" field.
func (m *CommentMutation) SetPostID(i int) {
	m.post = &i
}

// PostID returns the value of the "post_id" field in the mutation.
func (m *CommentMutation) PostID() (r int, exists bool) {
	v := m.post
	if v == nil {
		return
	}
	return *v, true
}

// OldPostID returns the old "post_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldPostID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostID: %w", err)
	}
	return oldValue.PostID, nil
}

// ResetPostID resets all changes to the "post_id" field.
func (m *CommentMutation) ResetPostID() {
	m.post = nil
}

// SetUserID sets the "user_id" field.
func (m *CommentMutation) SetUserID(i int) {
	m.author = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CommentMutation) UserID() (r int, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CommentMutation) ResetUserID() {
	m.author = nil
}

// SetParentID sets the "parent_id" field.
func (m *CommentMutation) SetParentID(i int) {
	m.parent = &i
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *CommentMutation) ParentID() (r int, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldParentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *CommentMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[comment.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *CommentMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[comment.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *CommentMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, comment.FieldParentID)
}

// SetReplyToUserID sets the "reply_to_user_id" field.
func (m *CommentMutation) SetReplyToUserID(i int) {
	m.reply_to_user = &i
}

// ReplyToUserID returns the value of the "reply_to_user_id" field in the mutation.
func (m *CommentMutation) ReplyToUserID() (r int, exists bool) {
	v := m.reply_to_user
	if v == nil {
		return
	}
	return *v, true
}

// OldReplyToUserID returns the old "reply_to_user_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldReplyToUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReplyToUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReplyToUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReplyToUserID: %w", err)
	}
	return oldValue.ReplyToUserID, nil
}

// ClearReplyToUserID clears the value of the "reply_to_user_id" field.
func (m *CommentMutation) ClearReplyToUserID() {
	m.reply_to_user = nil
	m.clearedFields[comment.FieldReplyToUserID] = struct{}{}
}

// ReplyToUserIDCleared returns if the "reply_to_user_id" field was cleared in this mutation.
func (m *CommentMutation) ReplyToUserIDCleared() bool {
	_, ok := m.clearedFields[comment.FieldReplyToUserID]
	return ok
}

// ResetReplyToUserID resets all changes to the "reply_to_user_id" field.
func (m *CommentMutation) ResetReplyToUserID() {
	m.reply_to_user = nil
	delete(m.clearedFields, comment.FieldReplyToUserID)
}

// SetContent sets the "content" field.
func (m *CommentMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *CommentMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *CommentMutation) ResetContent() {
	m.content = nil
}

// SetLikeCount sets the "like_count" field.
func (m *CommentMutation) SetLikeCount(i int) {
	m.like_count = &i
	m.addlike_count = nil
}

// LikeCount returns the value of the "like_count" field in the mutation.
func (m *CommentMutation) LikeCount() (r int, exists bool) {
	v := m.like_count
	if v == nil {
		return
	}
	return *v, true
}

// OldLikeCount returns the old "like_count" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldLikeCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLikeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLikeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLikeCount: %w", err)
	}
	return oldValue.LikeCount, nil
}

// AddLikeCount adds i to the "like_count" field.
func (m *CommentMutation) AddLikeCount(i int) {
	if m.addlike_count != nil {
		*m.addlike_count += i
	} else {
		m.addlike_count = &i
	}
}

// AddedLikeCount returns the value that was added to the "like_count" field in this mutation.
func (m *CommentMutation) AddedLikeCount() (r int, exists bool) {
	v := m.addlike_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetLikeCount resets all changes to the "like_count" field.
func (m *CommentMutation) ResetLikeCount() {
	m.like_count = nil
	m.addlike_count = nil
}

// SetDislikeCount sets the "dislike_count" field.
func (m *CommentMutation) SetDislikeCount(i int) {
	m.dislike_count = &i
	m.adddislike_count = nil
}

// DislikeCount returns the value of the "dislike_count" field in the mutation.
func (m *CommentMutation) DislikeCount() (r int, exists bool) {
	v := m.dislike_count
	if v == nil {
		return
	}
	return *v, true
}

// OldDislikeCount returns the old "dislike_count" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldDislikeCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDislikeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDislikeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDislikeCount: %w", err)
	}
	return oldValue.DislikeCount, nil
}

// AddDislikeCount adds i to the "dislike_count" field.
func (m *CommentMutation) AddDislikeCount(i int) {
	if m.adddislike_count != nil {
		*m.adddislike_count += i
	} else {
		m.adddislike_count = &i
	}
}

// AddedDislikeCount returns the value that was added to the "dislike_count" field in this mutation.
func (m *CommentMutation) AddedDislikeCount() (r int, exists bool) {
	v := m.adddislike_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetDislikeCount resets all changes to the "dislike_count" field.
func (m *CommentMutation) ResetDislikeCount() {
	m.dislike_count = nil
	m.adddislike_count = nil
}

// SetIsSelected sets the "is_selected" field.
func (m *CommentMutation) SetIsSelected(b bool) {
	m.is_selected = &b
}

// IsSelected returns the value of the "is_selected" field in the mutation.
func (m *CommentMutation) IsSelected() (r bool, exists bool) {
	v := m.is_selected
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSelected returns the old "is_selected" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldIsSelected(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsSelected is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsSelected requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSelected: %w", err)
	}
	return oldValue.IsSelected, nil
}

// ResetIsSelected resets all changes to the "is_selected" field.
func (m *CommentMutation) ResetIsSelected() {
	m.is_selected = nil
}

// SetIsPinned sets the "is_pinned" field.
func (m *CommentMutation) SetIsPinned(b bool) {
	m.is_pinned = &b
}

// IsPinned returns the value of the "is_pinned" field in the mutation.
func (m *CommentMutation) IsPinned() (r bool, exists bool) {
	v := m.is_pinned
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPinned returns the old "is_pinned" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldIsPinned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPinned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPinned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPinned: %w", err)
	}
	return oldValue.IsPinned, nil
}

// ResetIsPinned resets all changes to the "is_pinned" field.
func (m *CommentMutation) ResetIsPinned() {
	m.is_pinned = nil
}

// SetCommenterIP sets the "commenter_ip" field.
func (m *CommentMutation) SetCommenterIP(s string) {
	m.commenter_ip = &s
}

// CommenterIP returns the value of the "commenter_ip" field in the mutation.
func (m *CommentMutation) CommenterIP() (r string, exists bool) {
	v := m.commenter_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldCommenterIP returns the old "commenter_ip" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldCommenterIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommenterIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommenterIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommenterIP: %w", err)
	}
	return oldValue.CommenterIP, nil
}

// ClearCommenterIP clears the value of the "commenter_ip" field.
func (m *CommentMutation) ClearCommenterIP() {
	m.commenter_ip = nil
	m.clearedFields[comment.FieldCommenterIP] = struct{}{}
}

// CommenterIPCleared returns if the "commenter_ip" field was cleared in this mutation.
func (m *CommentMutation) CommenterIPCleared() bool {
	_, ok := m.clearedFields[comment.FieldCommenterIP]
	return ok
}

// ResetCommenterIP resets all changes to the "commenter_ip" field.
func (m *CommentMutation) ResetCommenterIP() {
	m.commenter_ip = nil
	delete(m.clearedFields, comment.FieldCommenterIP)
}

// SetDeviceInfo sets the "device_info" field.
func (m *CommentMutation) SetDeviceInfo(s string) {
	m.device_info = &s
}

// DeviceInfo returns the value of the "device_info" field in the mutation.
func (m *CommentMutation) DeviceInfo() (r string, exists bool) {
	v := m.device_info
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceInfo returns the old "device_info" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldDeviceInfo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceInfo: %w", err)
	}
	return oldValue.DeviceInfo, nil
}

// ClearDeviceInfo clears the value of the "device_info" field.
func (m *CommentMutation) ClearDeviceInfo() {
	m.device_info = nil
	m.clearedFields[comment.FieldDeviceInfo] = struct{}{}
}

// DeviceInfoCleared returns if the "device_info" field was cleared in this mutation.
func (m *CommentMutation) DeviceInfoCleared() bool {
	_, ok := m.clearedFields[comment.FieldDeviceInfo]
	return ok
}

// ResetDeviceInfo resets all changes to the "device_info" field.
func (m *CommentMutation) ResetDeviceInfo() {
	m.device_info = nil
	delete(m.clearedFields, comment.FieldDeviceInfo)
}

// ClearPost clears the "post" edge to the Post entity.
func (m *CommentMutation) ClearPost() {
	m.clearedpost = true
	m.clearedFields[comment.FieldPostID] = struct{}{}
}

// PostCleared reports if the "post" edge to the Post entity was cleared.
func (m *CommentMutation) PostCleared() bool {
	return m.clearedpost
}

// PostIDs returns the "post" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PostID instead. It exists only for internal usage by the builders.
func (m *CommentMutation) PostIDs() (ids []int) {
	if id := m.post; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPost resets all changes to the "post" edge.
func (m *CommentMutation) ResetPost() {
	m.post = nil
	m.clearedpost = false
}

// SetAuthorID sets the "author" edge to the User entity by id.
func (m *CommentMutation) SetAuthorID(id int) {
	m.author = &id
}

// ClearAuthor clears the "author" edge to the User entity.
func (m *CommentMutation) ClearAuthor() {
	m.clearedauthor = true
	m.clearedFields[comment.FieldUserID] = struct{}{}
}

// AuthorCleared reports if the "author" edge to the User entity was cleared.
func (m *CommentMutation) AuthorCleared() bool {
	return m.clearedauthor
}

// AuthorID returns the "author" edge ID in the mutation.
func (m *CommentMutation) AuthorID() (id int, exists bool) {
	if m.author != nil {
		return *m.author, true
	}
	return
}

// AuthorIDs returns the "author" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthorID instead. It exists only for internal usage by the builders.
func (m *CommentMutation) AuthorIDs() (ids []int) {
	if id := m.author; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthor resets all changes to the "author" edge.
func (m *CommentMutation) ResetAuthor() {
	m.author = nil
	m.clearedauthor = false
}

// ClearParent clears the "parent" edge to the Comment entity.
func (m *CommentMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[comment.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the Comment entity was cleared.
func (m *CommentMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *CommentMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *CommentMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// ClearReplyToUser clears the "reply_to_user" edge to the User entity.
func (m *CommentMutation) ClearReplyToUser() {
	m.clearedreply_to_user = true
	m.clearedFields[comment.FieldReplyToUserID] = struct{}{}
}

// ReplyToUserCleared reports if the "reply_to_user" edge to the User entity was cleared.
func (m *CommentMutation) ReplyToUserCleared() bool {
	return m.ReplyToUserIDCleared() || m.clearedreply_to_user
}

// ReplyToUserIDs returns the "reply_to_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReplyToUserID instead. It exists only for internal usage by the builders.
func (m *CommentMutation) ReplyToUserIDs() (ids []int) {
	if id := m.reply_to_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReplyToUser resets all changes to the "reply_to_user" edge.
func (m *CommentMutation) ResetReplyToUser() {
	m.reply_to_user = nil
	m.clearedreply_to_user = false
}

// Where appends a list predicates to the CommentMutation builder.
func (m *CommentMutation) Where(ps ...predicate.Comment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CommentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CommentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Comment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CommentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CommentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Comment).
func (m *CommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommentMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, comment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, comment.FieldUpdatedAt)
	}
	if m.post != nil {
		fields = append(fields, comment.FieldPostID)
	}
	if m.author != nil {
		fields = append(fields, comment.FieldUserID)
	}
	if m.parent != nil {
		fields = append(fields, comment.FieldParentID)
	}
	if m.reply_to_user != nil {
		fields = append(fields, comment.FieldReplyToUserID)
	}
	if m.content != nil {
		fields = append(fields, comment.FieldContent)
	}
	if m.like_count != nil {
		fields = append(fields, comment.FieldLikeCount)
	}
	if m.dislike_count != nil {
		fields = append(fields, comment.FieldDislikeCount)
	}
	if m.is_selected != nil {
		fields = append(fields, comment.FieldIsSelected)
	}
	if m.is_pinned != nil {
		fields = append(fields, comment.FieldIsPinned)
	}
	if m.commenter_ip != nil {
		fields = append(fields, comment.FieldCommenterIP)
	}
	if m.device_info != nil {
		fields = append(fields, comment.FieldDeviceInfo)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case comment.FieldCreatedAt:
		return m.CreatedAt()
	case comment.FieldUpdatedAt:
		return m.UpdatedAt()
	case comment.FieldPostID:
		return m.PostID()
	case comment.FieldUserID:
		return m.UserID()
	case comment.FieldParentID:
		return m.ParentID()
	case comment.FieldReplyToUserID:
		return m.ReplyToUserID()
	case comment.FieldContent:
		return m.Content()
	case comment.FieldLikeCount:
		return m.LikeCount()
	case comment.FieldDislikeCount:
		return m.DislikeCount()
	case comment.FieldIsSelected:
		return m.IsSelected()
	case comment.FieldIsPinned:
		return m.IsPinned()
	case comment.FieldCommenterIP:
		return m.CommenterIP()
	case comment.FieldDeviceInfo:
		return m.DeviceInfo()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case comment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case comment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case comment.FieldPostID:
		return m.OldPostID(ctx)
	case comment.FieldUserID:
		return m.OldUserID(ctx)
	case comment.FieldParentID:
		return m.OldParentID(ctx)
	case comment.FieldReplyToUserID:
		return m.OldReplyToUserID(ctx)
	case comment.FieldContent:
		return m.OldContent(ctx)
	case comment.FieldLikeCount:
		return m.OldLikeCount(ctx)
	case comment.FieldDislikeCount:
		return m.OldDislikeCount(ctx)
	case comment.FieldIsSelected:
		return m.OldIsSelected(ctx)
	case comment.FieldIsPinned:
		return m.OldIsPinned(ctx)
	case comment.FieldCommenterIP:
		return m.OldCommenterIP(ctx)
	case comment.FieldDeviceInfo:
		return m.OldDeviceInfo(ctx)
	}
	return nil, fmt.Errorf("unknown Comment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case comment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case comment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case comment.FieldPostID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostID(v)
		return nil
	case comment.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case comment.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case comment.FieldReplyToUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReplyToUserID(v)
		return nil
	case comment.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case comment.FieldLikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikeCount(v)
		return nil
	case comment.FieldDislikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDislikeCount(v)
		return nil
	case comment.FieldIsSelected:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSelected(v)
		return nil
	case comment.FieldIsPinned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPinned(v)
		return nil
	case comment.FieldCommenterIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommenterIP(v)
		return nil
	case comment.FieldDeviceInfo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceInfo(v)
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommentMutation) AddedFields() []string {
	var fields []string
	if m.addlike_count != nil {
		fields = append(fields, comment.FieldLikeCount)
	}
	if m.adddislike_count != nil {
		fields = append(fields, comment.FieldDislikeCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case comment.FieldLikeCount:
		return m.AddedLikeCount()
	case comment.FieldDislikeCount:
		return m.AddedDislikeCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case comment.FieldLikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLikeCount(v)
		return nil
	case comment.FieldDislikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDislikeCount(v)
		return nil
	}
	return fmt.Errorf("unknown Comment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(comment.FieldParentID) {
		fields = append(fields, comment.FieldParentID)
	}
	if m.FieldCleared(comment.FieldReplyToUserID) {
		fields = append(fields, comment.FieldReplyToUserID)
	}
	if m.FieldCleared(comment.FieldCommenterIP) {
		fields = append(fields, comment.FieldCommenterIP)
	}
	if m.FieldCleared(comment.FieldDeviceInfo) {
		fields = append(fields, comment.FieldDeviceInfo)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommentMutation) ClearField(name string) error {
	switch name {
	case comment.FieldParentID:
		m.ClearParentID()
		return nil
	case comment.FieldReplyToUserID:
		m.ClearReplyToUserID()
		return nil
	case comment.FieldCommenterIP:
		m.ClearCommenterIP()
		return nil
	case comment.FieldDeviceInfo:
		m.ClearDeviceInfo()
		return nil
	}
	return fmt.Errorf("unknown Comment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommentMutation) ResetField(name string) error {
	switch name {
	case comment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case comment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case comment.FieldPostID:
		m.ResetPostID()
		return nil
	case comment.FieldUserID:
		m.ResetUserID()
		return nil
	case comment.FieldParentID:
		m.ResetParentID()
		return nil
	case comment.FieldReplyToUserID:
		m.ResetReplyToUserID()
		return nil
	case comment.FieldContent:
		m.ResetContent()
		return nil
	case comment.FieldLikeCount:
		m.ResetLikeCount()
		return nil
	case comment.FieldDislikeCount:
		m.ResetDislikeCount()
		return nil
	case comment.FieldIsSelected:
		m.ResetIsSelected()
		return nil
	case comment.FieldIsPinned:
		m.ResetIsPinned()
		return nil
	case comment.FieldCommenterIP:
		m.ResetCommenterIP()
		return nil
	case comment.FieldDeviceInfo:
		m.ResetDeviceInfo()
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.post != nil {
		edges = append(edges, comment.EdgePost)
	}
	if m.author != nil {
		edges = append(edges, comment.EdgeAuthor)
	}
	if m.parent != nil {
		edges = append(edges, comment.EdgeParent)
	}
	if m.reply_to_user != nil {
		edges = append(edges, comment.EdgeReplyToUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case comment.EdgePost:
		if id := m.post; id != nil {
			return []ent.Value{*id}
		}
	case comment.EdgeAuthor:
		if id := m.author; id != nil {
			return []ent.Value{*id}
		}
	case comment.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case comment.EdgeReplyToUser:
		if id := m.reply_to_user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedpost {
		edges = append(edges, comment.EdgePost)
	}
	if m.clearedauthor {
		edges = append(edges, comment.EdgeAuthor)
	}
	if m.clearedparent {
		edges = append(edges, comment.EdgeParent)
	}
	if m.clearedreply_to_user {
		edges = append(edges, comment.EdgeReplyToUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommentMutation) EdgeCleared(name string) bool {
	switch name {
	case comment.EdgePost:
		return m.clearedpost
	case comment.EdgeAuthor:
		return m.clearedauthor
	case comment.EdgeParent:
		return m.clearedparent
	case comment.EdgeReplyToUser:
		return m.clearedreply_to_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommentMutation) ClearEdge(name string) error {
	switch name {
	case comment.EdgePost:
		m.ClearPost()
		return nil
	case comment.EdgeAuthor:
		m.ClearAuthor()
		return nil
	case comment.EdgeParent:
		m.ClearParent()
		return nil
	case comment.EdgeReplyToUser:
		m.ClearReplyToUser()
		return nil
	}
	return fmt.Errorf("unknown Comment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommentMutation) ResetEdge(name string) error {
	switch name {
	case comment.EdgePost:
		m.ResetPost()
		return nil
	case comment.EdgeAuthor:
		m.ResetAuthor()
		return nil
	case comment.EdgeParent:
		m.ResetParent()
		return nil
	case comment.EdgeReplyToUser:
		m.ResetReplyToUser()
		return nil
	}
	return fmt.Errorf("unknown Comment edge %s", name)
}

// CommentActionMutation represents an operation that mutates the CommentAction nodes in the graph.
type CommentActionMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	action_type    *commentaction.ActionType
	clearedFields  map[string]struct{}
	user           *int
	cleareduser    bool
	comment        *int
	clearedcomment bool
	done           bool
	oldValue       func(context.Context) (*CommentAction, error)
	predicates     []predicate.CommentAction
}

var _ ent.Mutation = (*CommentActionMutation)(nil)

// commentactionOption allows management of the mutation configuration using functional options.
type commentactionOption func(*CommentActionMutation)

// newCommentActionMutation creates new mutation for the CommentAction entity.
func newCommentActionMutation(c config, op Op, opts ...commentactionOption) *CommentActionMutation {
	m := &CommentActionMutation{
		config:        c,
		op:            op,
		typ:           TypeCommentAction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommentActionID sets the ID field of the mutation.
func withCommentActionID(id int) commentactionOption {
	return func(m *CommentActionMutation) {
		var (
			err   error
			once  sync.Once
			value *CommentAction
		)
		m.oldValue = func(ctx context.Context) (*CommentAction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CommentAction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCommentAction sets the old CommentAction of the mutation.
func withCommentAction(node *CommentAction) commentactionOption {
	return func(m *CommentActionMutation) {
		m.oldValue = func(context.Context) (*CommentAction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommentActionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommentActionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CommentAction entities.
func (m *CommentActionMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommentActionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommentActionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CommentAction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CommentActionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CommentActionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CommentAction entity.
// If the CommentAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentActionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CommentActionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CommentActionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CommentActionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CommentAction entity.
// If the CommentAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentActionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CommentActionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *CommentActionMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CommentActionMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the CommentAction entity.
// If the CommentAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentActionMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CommentActionMutation) ResetUserID() {
	m.user = nil
}

// SetCommentID sets the "comment_id" field.
func (m *CommentActionMutation) SetCommentID(i int) {
	m.comment = &i
}

// CommentID returns the value of the "comment_id" field in the mutation.
func (m *CommentActionMutation) CommentID() (r int, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldCommentID returns the old "comment_id" field's value of the CommentAction entity.
// If the CommentAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentActionMutation) OldCommentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommentID: %w", err)
	}
	return oldValue.CommentID, nil
}

// ResetCommentID resets all changes to the "comment_id" field.
func (m *CommentActionMutation) ResetCommentID() {
	m.comment = nil
}

// SetActionType sets the "action_type" field.
func (m *CommentActionMutation) SetActionType(ct commentaction.ActionType) {
	m.action_type = &ct
}

// ActionType returns the value of the "action_type" field in the mutation.
func (m *CommentActionMutation) ActionType() (r commentaction.ActionType, exists bool) {
	v := m.action_type
	if v == nil {
		return
	}
	return *v, true
}

// OldActionType returns the old "action_type" field's value of the CommentAction entity.
// If the CommentAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentActionMutation) OldActionType(ctx context.Context) (v commentaction.ActionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionType: %w", err)
	}
	return oldValue.ActionType, nil
}

// ResetActionType resets all changes to the "action_type" field.
func (m *CommentActionMutation) ResetActionType() {
	m.action_type = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *CommentActionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[commentaction.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CommentActionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CommentActionMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CommentActionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearComment clears the "comment" edge to the Comment entity.
func (m *CommentActionMutation) ClearComment() {
	m.clearedcomment = true
	m.clearedFields[commentaction.FieldCommentID] = struct{}{}
}

// CommentCleared reports if the "comment" edge to the Comment entity was cleared.
func (m *CommentActionMutation) CommentCleared() bool {
	return m.clearedcomment
}

// CommentIDs returns the "comment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CommentID instead. It exists only for internal usage by the builders.
func (m *CommentActionMutation) CommentIDs() (ids []int) {
	if id := m.comment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetComment resets all changes to the "comment" edge.
func (m *CommentActionMutation) ResetComment() {
	m.comment = nil
	m.clearedcomment = false
}

// Where appends a list predicates to the CommentActionMutation builder.
func (m *CommentActionMutation) Where(ps ...predicate.CommentAction) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CommentActionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CommentActionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CommentAction, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CommentActionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CommentActionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CommentAction).
func (m *CommentActionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommentActionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, commentaction.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, commentaction.FieldUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, commentaction.FieldUserID)
	}
	if m.comment != nil {
		fields = append(fields, commentaction.FieldCommentID)
	}
	if m.action_type != nil {
		fields = append(fields, commentaction.FieldActionType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommentActionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case commentaction.FieldCreatedAt:
		return m.CreatedAt()
	case commentaction.FieldUpdatedAt:
		return m.UpdatedAt()
	case commentaction.FieldUserID:
		return m.UserID()
	case commentaction.FieldCommentID:
		return m.CommentID()
	case commentaction.FieldActionType:
		return m.ActionType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommentActionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case commentaction.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case commentaction.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case commentaction.FieldUserID:
		return m.OldUserID(ctx)
	case commentaction.FieldCommentID:
		return m.OldCommentID(ctx)
	case commentaction.FieldActionType:
		return m.OldActionType(ctx)
	}
	return nil, fmt.Errorf("unknown CommentAction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentActionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case commentaction.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case commentaction.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case commentaction.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case commentaction.FieldCommentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommentID(v)
		return nil
	case commentaction.FieldActionType:
		v, ok := value.(commentaction.ActionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionType(v)
		return nil
	}
	return fmt.Errorf("unknown CommentAction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommentActionMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommentActionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentActionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CommentAction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommentActionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommentActionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommentActionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CommentAction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommentActionMutation) ResetField(name string) error {
	switch name {
	case commentaction.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case commentaction.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case commentaction.FieldUserID:
		m.ResetUserID()
		return nil
	case commentaction.FieldCommentID:
		m.ResetCommentID()
		return nil
	case commentaction.FieldActionType:
		m.ResetActionType()
		return nil
	}
	return fmt.Errorf("unknown CommentAction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommentActionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, commentaction.EdgeUser)
	}
	if m.comment != nil {
		edges = append(edges, commentaction.EdgeComment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommentActionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case commentaction.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case commentaction.EdgeComment:
		if id := m.comment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommentActionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommentActionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommentActionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, commentaction.EdgeUser)
	}
	if m.clearedcomment {
		edges = append(edges, commentaction.EdgeComment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommentActionMutation) EdgeCleared(name string) bool {
	switch name {
	case commentaction.EdgeUser:
		return m.cleareduser
	case commentaction.EdgeComment:
		return m.clearedcomment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommentActionMutation) ClearEdge(name string) error {
	switch name {
	case commentaction.EdgeUser:
		m.ClearUser()
		return nil
	case commentaction.EdgeComment:
		m.ClearComment()
		return nil
	}
	return fmt.Errorf("unknown CommentAction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommentActionMutation) ResetEdge(name string) error {
	switch name {
	case commentaction.EdgeUser:
		m.ResetUser()
		return nil
	case commentaction.EdgeComment:
		m.ResetComment()
		return nil
	}
	return fmt.Errorf("unknown CommentAction edge %s", name)
}

// PostMutation represents an operation that mutates the Post nodes in the graph.
type PostMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	title             *string
	content           *string
	read_permission   *string
	view_count        *int
	addview_count     *int
	like_count        *int
	addlike_count     *int
	dislike_count     *int
	adddislike_count  *int
	favorite_count    *int
	addfavorite_count *int
	is_essence        *bool
	is_pinned         *bool
	publish_ip        *string
	status            *post.Status
	clearedFields     map[string]struct{}
	author            *int
	clearedauthor     bool
	category          *int
	clearedcategory   bool
	done              bool
	oldValue          func(context.Context) (*Post, error)
	predicates        []predicate.Post
}

var _ ent.Mutation = (*PostMutation)(nil)

// postOption allows management of the mutation configuration using functional options.
type postOption func(*PostMutation)

// newPostMutation creates new mutation for the Post entity.
func newPostMutation(c config, op Op, opts ...postOption) *PostMutation {
	m := &PostMutation{
		config:        c,
		op:            op,
		typ:           TypePost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPostID sets the ID field of the mutation.
func withPostID(id int) postOption {
	return func(m *PostMutation) {
		var (
			err   error
			once  sync.Once
			value *Post
		)
		m.oldValue = func(ctx context.Context) (*Post, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Post.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPost sets the old Post of the mutation.
func withPost(node *Post) postOption {
	return func(m *PostMutation) {
		m.oldValue = func(context.Context) (*Post, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Post entities.
func (m *PostMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PostMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PostMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Post.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PostMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PostMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PostMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PostMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PostMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PostMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *PostMutation) SetUserID(i int) {
	m.author = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *PostMutation) UserID() (r int, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *PostMutation) ResetUserID() {
	m.author = nil
}

// SetCategoryID sets the "category_id" field.
func (m *PostMutation) SetCategoryID(i int) {
	m.category = &i
}

// CategoryID returns the value of the "category_id" field in the mutation.
func (m *PostMutation) CategoryID() (r int, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "category_id" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldCategoryID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// ResetCategoryID resets all changes to the "category_id" field.
func (m *PostMutation) ResetCategoryID() {
	m.category = nil
}

// SetTitle sets the "title" field.
func (m *PostMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *PostMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *PostMutation) ResetTitle() {
	m.title = nil
}

// SetContent sets the "content" field.
func (m *PostMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *PostMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *PostMutation) ResetContent() {
	m.content = nil
}

// SetReadPermission sets the "read_permission" field.
func (m *PostMutation) SetReadPermission(s string) {
	m.read_permission = &s
}

// ReadPermission returns the value of the "read_permission" field in the mutation.
func (m *PostMutation) ReadPermission() (r string, exists bool) {
	v := m.read_permission
	if v == nil {
		return
	}
	return *v, true
}

// OldReadPermission returns the old "read_permission" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldReadPermission(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReadPermission is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReadPermission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReadPermission: %w", err)
	}
	return oldValue.ReadPermission, nil
}

// ClearReadPermission clears the value of the "read_permission" field.
func (m *PostMutation) ClearReadPermission() {
	m.read_permission = nil
	m.clearedFields[post.FieldReadPermission] = struct{}{}
}

// ReadPermissionCleared returns if the "read_permission" field was cleared in this mutation.
func (m *PostMutation) ReadPermissionCleared() bool {
	_, ok := m.clearedFields[post.FieldReadPermission]
	return ok
}

// ResetReadPermission resets all changes to the "read_permission" field.
func (m *PostMutation) ResetReadPermission() {
	m.read_permission = nil
	delete(m.clearedFields, post.FieldReadPermission)
}

// SetViewCount sets the "view_count" field.
func (m *PostMutation) SetViewCount(i int) {
	m.view_count = &i
	m.addview_count = nil
}

// ViewCount returns the value of the "view_count" field in the mutation.
func (m *PostMutation) ViewCount() (r int, exists bool) {
	v := m.view_count
	if v == nil {
		return
	}
	return *v, true
}

// OldViewCount returns the old "view_count" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldViewCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldViewCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldViewCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldViewCount: %w", err)
	}
	return oldValue.ViewCount, nil
}

// AddViewCount adds i to the "view_count" field.
func (m *PostMutation) AddViewCount(i int) {
	if m.addview_count != nil {
		*m.addview_count += i
	} else {
		m.addview_count = &i
	}
}

// AddedViewCount returns the value that was added to the "view_count" field in this mutation.
func (m *PostMutation) AddedViewCount() (r int, exists bool) {
	v := m.addview_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetViewCount resets all changes to the "view_count" field.
func (m *PostMutation) ResetViewCount() {
	m.view_count = nil
	m.addview_count = nil
}

// SetLikeCount sets the "like_count" field.
func (m *PostMutation) SetLikeCount(i int) {
	m.like_count = &i
	m.addlike_count = nil
}

// LikeCount returns the value of the "like_count" field in the mutation.
func (m *PostMutation) LikeCount() (r int, exists bool) {
	v := m.like_count
	if v == nil {
		return
	}
	return *v, true
}

// OldLikeCount returns the old "like_count" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldLikeCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLikeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLikeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLikeCount: %w", err)
	}
	return oldValue.LikeCount, nil
}

// AddLikeCount adds i to the "like_count" field.
func (m *PostMutation) AddLikeCount(i int) {
	if m.addlike_count != nil {
		*m.addlike_count += i
	} else {
		m.addlike_count = &i
	}
}

// AddedLikeCount returns the value that was added to the "like_count" field in this mutation.
func (m *PostMutation) AddedLikeCount() (r int, exists bool) {
	v := m.addlike_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetLikeCount resets all changes to the "like_count" field.
func (m *PostMutation) ResetLikeCount() {
	m.like_count = nil
	m.addlike_count = nil
}

// SetDislikeCount sets the "dislike_count" field.
func (m *PostMutation) SetDislikeCount(i int) {
	m.dislike_count = &i
	m.adddislike_count = nil
}

// DislikeCount returns the value of the "dislike_count" field in the mutation.
func (m *PostMutation) DislikeCount() (r int, exists bool) {
	v := m.dislike_count
	if v == nil {
		return
	}
	return *v, true
}

// OldDislikeCount returns the old "dislike_count" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldDislikeCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDislikeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDislikeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDislikeCount: %w", err)
	}
	return oldValue.DislikeCount, nil
}

// AddDislikeCount adds i to the "dislike_count" field.
func (m *PostMutation) AddDislikeCount(i int) {
	if m.adddislike_count != nil {
		*m.adddislike_count += i
	} else {
		m.adddislike_count = &i
	}
}

// AddedDislikeCount returns the value that was added to the "dislike_count" field in this mutation.
func (m *PostMutation) AddedDislikeCount() (r int, exists bool) {
	v := m.adddislike_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetDislikeCount resets all changes to the "dislike_count" field.
func (m *PostMutation) ResetDislikeCount() {
	m.dislike_count = nil
	m.adddislike_count = nil
}

// SetFavoriteCount sets the "favorite_count" field.
func (m *PostMutation) SetFavoriteCount(i int) {
	m.favorite_count = &i
	m.addfavorite_count = nil
}

// FavoriteCount returns the value of the "favorite_count" field in the mutation.
func (m *PostMutation) FavoriteCount() (r int, exists bool) {
	v := m.favorite_count
	if v == nil {
		return
	}
	return *v, true
}

// OldFavoriteCount returns the old "favorite_count" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldFavoriteCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFavoriteCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFavoriteCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFavoriteCount: %w", err)
	}
	return oldValue.FavoriteCount, nil
}

// AddFavoriteCount adds i to the "favorite_count" field.
func (m *PostMutation) AddFavoriteCount(i int) {
	if m.addfavorite_count != nil {
		*m.addfavorite_count += i
	} else {
		m.addfavorite_count = &i
	}
}

// AddedFavoriteCount returns the value that was added to the "favorite_count" field in this mutation.
func (m *PostMutation) AddedFavoriteCount() (r int, exists bool) {
	v := m.addfavorite_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetFavoriteCount resets all changes to the "favorite_count" field.
func (m *PostMutation) ResetFavoriteCount() {
	m.favorite_count = nil
	m.addfavorite_count = nil
}

// SetIsEssence sets the "is_essence" field.
func (m *PostMutation) SetIsEssence(b bool) {
	m.is_essence = &b
}

// IsEssence returns the value of the "is_essence" field in the mutation.
func (m *PostMutation) IsEssence() (r bool, exists bool) {
	v := m.is_essence
	if v == nil {
		return
	}
	return *v, true
}

// OldIsEssence returns the old "is_essence" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldIsEssence(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsEssence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsEssence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsEssence: %w", err)
	}
	return oldValue.IsEssence, nil
}

// ResetIsEssence resets all changes to the "is_essence" field.
func (m *PostMutation) ResetIsEssence() {
	m.is_essence = nil
}

// SetIsPinned sets the "is_pinned" field.
func (m *PostMutation) SetIsPinned(b bool) {
	m.is_pinned = &b
}

// IsPinned returns the value of the "is_pinned" field in the mutation.
func (m *PostMutation) IsPinned() (r bool, exists bool) {
	v := m.is_pinned
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPinned returns the old "is_pinned" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldIsPinned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPinned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPinned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPinned: %w", err)
	}
	return oldValue.IsPinned, nil
}

// ResetIsPinned resets all changes to the "is_pinned" field.
func (m *PostMutation) ResetIsPinned() {
	m.is_pinned = nil
}

// SetPublishIP sets the "publish_ip" field.
func (m *PostMutation) SetPublishIP(s string) {
	m.publish_ip = &s
}

// PublishIP returns the value of the "publish_ip" field in the mutation.
func (m *PostMutation) PublishIP() (r string, exists bool) {
	v := m.publish_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldPublishIP returns the old "publish_ip" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldPublishIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublishIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublishIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublishIP: %w", err)
	}
	return oldValue.PublishIP, nil
}

// ClearPublishIP clears the value of the "publish_ip" field.
func (m *PostMutation) ClearPublishIP() {
	m.publish_ip = nil
	m.clearedFields[post.FieldPublishIP] = struct{}{}
}

// PublishIPCleared returns if the "publish_ip" field was cleared in this mutation.
func (m *PostMutation) PublishIPCleared() bool {
	_, ok := m.clearedFields[post.FieldPublishIP]
	return ok
}

// ResetPublishIP resets all changes to the "publish_ip" field.
func (m *PostMutation) ResetPublishIP() {
	m.publish_ip = nil
	delete(m.clearedFields, post.FieldPublishIP)
}

// SetStatus sets the "status" field.
func (m *PostMutation) SetStatus(po post.Status) {
	m.status = &po
}

// Status returns the value of the "status" field in the mutation.
func (m *PostMutation) Status() (r post.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldStatus(ctx context.Context) (v post.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PostMutation) ResetStatus() {
	m.status = nil
}

// SetAuthorID sets the "author" edge to the User entity by id.
func (m *PostMutation) SetAuthorID(id int) {
	m.author = &id
}

// ClearAuthor clears the "author" edge to the User entity.
func (m *PostMutation) ClearAuthor() {
	m.clearedauthor = true
	m.clearedFields[post.FieldUserID] = struct{}{}
}

// AuthorCleared reports if the "author" edge to the User entity was cleared.
func (m *PostMutation) AuthorCleared() bool {
	return m.clearedauthor
}

// AuthorID returns the "author" edge ID in the mutation.
func (m *PostMutation) AuthorID() (id int, exists bool) {
	if m.author != nil {
		return *m.author, true
	}
	return
}

// AuthorIDs returns the "author" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthorID instead. It exists only for internal usage by the builders.
func (m *PostMutation) AuthorIDs() (ids []int) {
	if id := m.author; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthor resets all changes to the "author" edge.
func (m *PostMutation) ResetAuthor() {
	m.author = nil
	m.clearedauthor = false
}

// ClearCategory clears the "category" edge to the Category entity.
func (m *PostMutation) ClearCategory() {
	m.clearedcategory = true
	m.clearedFields[post.FieldCategoryID] = struct{}{}
}

// CategoryCleared reports if the "category" edge to the Category entity was cleared.
func (m *PostMutation) CategoryCleared() bool {
	return m.clearedcategory
}

// CategoryIDs returns the "category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CategoryID instead. It exists only for internal usage by the builders.
func (m *PostMutation) CategoryIDs() (ids []int) {
	if id := m.category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCategory resets all changes to the "category" edge.
func (m *PostMutation) ResetCategory() {
	m.category = nil
	m.clearedcategory = false
}

// Where appends a list predicates to the PostMutation builder.
func (m *PostMutation) Where(ps ...predicate.Post) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PostMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PostMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Post, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PostMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PostMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Post).
func (m *PostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PostMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, post.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, post.FieldUpdatedAt)
	}
	if m.author != nil {
		fields = append(fields, post.FieldUserID)
	}
	if m.category != nil {
		fields = append(fields, post.FieldCategoryID)
	}
	if m.title != nil {
		fields = append(fields, post.FieldTitle)
	}
	if m.content != nil {
		fields = append(fields, post.FieldContent)
	}
	if m.read_permission != nil {
		fields = append(fields, post.FieldReadPermission)
	}
	if m.view_count != nil {
		fields = append(fields, post.FieldViewCount)
	}
	if m.like_count != nil {
		fields = append(fields, post.FieldLikeCount)
	}
	if m.dislike_count != nil {
		fields = append(fields, post.FieldDislikeCount)
	}
	if m.favorite_count != nil {
		fields = append(fields, post.FieldFavoriteCount)
	}
	if m.is_essence != nil {
		fields = append(fields, post.FieldIsEssence)
	}
	if m.is_pinned != nil {
		fields = append(fields, post.FieldIsPinned)
	}
	if m.publish_ip != nil {
		fields = append(fields, post.FieldPublishIP)
	}
	if m.status != nil {
		fields = append(fields, post.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case post.FieldCreatedAt:
		return m.CreatedAt()
	case post.FieldUpdatedAt:
		return m.UpdatedAt()
	case post.FieldUserID:
		return m.UserID()
	case post.FieldCategoryID:
		return m.CategoryID()
	case post.FieldTitle:
		return m.Title()
	case post.FieldContent:
		return m.Content()
	case post.FieldReadPermission:
		return m.ReadPermission()
	case post.FieldViewCount:
		return m.ViewCount()
	case post.FieldLikeCount:
		return m.LikeCount()
	case post.FieldDislikeCount:
		return m.DislikeCount()
	case post.FieldFavoriteCount:
		return m.FavoriteCount()
	case post.FieldIsEssence:
		return m.IsEssence()
	case post.FieldIsPinned:
		return m.IsPinned()
	case post.FieldPublishIP:
		return m.PublishIP()
	case post.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case post.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case post.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case post.FieldUserID:
		return m.OldUserID(ctx)
	case post.FieldCategoryID:
		return m.OldCategoryID(ctx)
	case post.FieldTitle:
		return m.OldTitle(ctx)
	case post.FieldContent:
		return m.OldContent(ctx)
	case post.FieldReadPermission:
		return m.OldReadPermission(ctx)
	case post.FieldViewCount:
		return m.OldViewCount(ctx)
	case post.FieldLikeCount:
		return m.OldLikeCount(ctx)
	case post.FieldDislikeCount:
		return m.OldDislikeCount(ctx)
	case post.FieldFavoriteCount:
		return m.OldFavoriteCount(ctx)
	case post.FieldIsEssence:
		return m.OldIsEssence(ctx)
	case post.FieldIsPinned:
		return m.OldIsPinned(ctx)
	case post.FieldPublishIP:
		return m.OldPublishIP(ctx)
	case post.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Post field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case post.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case post.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case post.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case post.FieldCategoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	case post.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case post.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case post.FieldReadPermission:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReadPermission(v)
		return nil
	case post.FieldViewCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetViewCount(v)
		return nil
	case post.FieldLikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikeCount(v)
		return nil
	case post.FieldDislikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDislikeCount(v)
		return nil
	case post.FieldFavoriteCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFavoriteCount(v)
		return nil
	case post.FieldIsEssence:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsEssence(v)
		return nil
	case post.FieldIsPinned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPinned(v)
		return nil
	case post.FieldPublishIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublishIP(v)
		return nil
	case post.FieldStatus:
		v, ok := value.(post.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Post field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PostMutation) AddedFields() []string {
	var fields []string
	if m.addview_count != nil {
		fields = append(fields, post.FieldViewCount)
	}
	if m.addlike_count != nil {
		fields = append(fields, post.FieldLikeCount)
	}
	if m.adddislike_count != nil {
		fields = append(fields, post.FieldDislikeCount)
	}
	if m.addfavorite_count != nil {
		fields = append(fields, post.FieldFavoriteCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PostMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case post.FieldViewCount:
		return m.AddedViewCount()
	case post.FieldLikeCount:
		return m.AddedLikeCount()
	case post.FieldDislikeCount:
		return m.AddedDislikeCount()
	case post.FieldFavoriteCount:
		return m.AddedFavoriteCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostMutation) AddField(name string, value ent.Value) error {
	switch name {
	case post.FieldViewCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddViewCount(v)
		return nil
	case post.FieldLikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLikeCount(v)
		return nil
	case post.FieldDislikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDislikeCount(v)
		return nil
	case post.FieldFavoriteCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFavoriteCount(v)
		return nil
	}
	return fmt.Errorf("unknown Post numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PostMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(post.FieldReadPermission) {
		fields = append(fields, post.FieldReadPermission)
	}
	if m.FieldCleared(post.FieldPublishIP) {
		fields = append(fields, post.FieldPublishIP)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PostMutation) ClearField(name string) error {
	switch name {
	case post.FieldReadPermission:
		m.ClearReadPermission()
		return nil
	case post.FieldPublishIP:
		m.ClearPublishIP()
		return nil
	}
	return fmt.Errorf("unknown Post nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PostMutation) ResetField(name string) error {
	switch name {
	case post.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case post.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case post.FieldUserID:
		m.ResetUserID()
		return nil
	case post.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	case post.FieldTitle:
		m.ResetTitle()
		return nil
	case post.FieldContent:
		m.ResetContent()
		return nil
	case post.FieldReadPermission:
		m.ResetReadPermission()
		return nil
	case post.FieldViewCount:
		m.ResetViewCount()
		return nil
	case post.FieldLikeCount:
		m.ResetLikeCount()
		return nil
	case post.FieldDislikeCount:
		m.ResetDislikeCount()
		return nil
	case post.FieldFavoriteCount:
		m.ResetFavoriteCount()
		return nil
	case post.FieldIsEssence:
		m.ResetIsEssence()
		return nil
	case post.FieldIsPinned:
		m.ResetIsPinned()
		return nil
	case post.FieldPublishIP:
		m.ResetPublishIP()
		return nil
	case post.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Post field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PostMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.author != nil {
		edges = append(edges, post.EdgeAuthor)
	}
	if m.category != nil {
		edges = append(edges, post.EdgeCategory)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case post.EdgeAuthor:
		if id := m.author; id != nil {
			return []ent.Value{*id}
		}
	case post.EdgeCategory:
		if id := m.category; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PostMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedauthor {
		edges = append(edges, post.EdgeAuthor)
	}
	if m.clearedcategory {
		edges = append(edges, post.EdgeCategory)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PostMutation) EdgeCleared(name string) bool {
	switch name {
	case post.EdgeAuthor:
		return m.clearedauthor
	case post.EdgeCategory:
		return m.clearedcategory
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PostMutation) ClearEdge(name string) error {
	switch name {
	case post.EdgeAuthor:
		m.ClearAuthor()
		return nil
	case post.EdgeCategory:
		m.ClearCategory()
		return nil
	}
	return fmt.Errorf("unknown Post unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PostMutation) ResetEdge(name string) error {
	switch name {
	case post.EdgeAuthor:
		m.ResetAuthor()
		return nil
	case post.EdgeCategory:
		m.ResetCategory()
		return nil
	}
	return fmt.Errorf("unknown Post edge %s", name)
}

// PostActionMutation represents an operation that mutates the PostAction nodes in the graph.
type PostActionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	action_type   *postaction.ActionType
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	post          *int
	clearedpost   bool
	done          bool
	oldValue      func(context.Context) (*PostAction, error)
	predicates    []predicate.PostAction
}

var _ ent.Mutation = (*PostActionMutation)(nil)

// postactionOption allows management of the mutation configuration using functional options.
type postactionOption func(*PostActionMutation)

// newPostActionMutation creates new mutation for the PostAction entity.
func newPostActionMutation(c config, op Op, opts ...postactionOption) *PostActionMutation {
	m := &PostActionMutation{
		config:        c,
		op:            op,
		typ:           TypePostAction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPostActionID sets the ID field of the mutation.
func withPostActionID(id int) postactionOption {
	return func(m *PostActionMutation) {
		var (
			err   error
			once  sync.Once
			value *PostAction
		)
		m.oldValue = func(ctx context.Context) (*PostAction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PostAction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPostAction sets the old PostAction of the mutation.
func withPostAction(node *PostAction) postactionOption {
	return func(m *PostActionMutation) {
		m.oldValue = func(context.Context) (*PostAction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PostActionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PostActionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PostAction entities.
func (m *PostActionMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PostActionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PostActionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PostAction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PostActionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PostActionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PostAction entity.
// If the PostAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostActionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PostActionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PostActionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PostActionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PostAction entity.
// If the PostAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostActionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PostActionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *PostActionMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *PostActionMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the PostAction entity.
// If the PostAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostActionMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *PostActionMutation) ResetUserID() {
	m.user = nil
}

// SetPostID sets the "post_id" field.
func (m *PostActionMutation) SetPostID(i int) {
	m.post = &i
}

// PostID returns the value of the "post_id" field in the mutation.
func (m *PostActionMutation) PostID() (r int, exists bool) {
	v := m.post
	if v == nil {
		return
	}
	return *v, true
}

// OldPostID returns the old "post_id" field's value of the PostAction entity.
// If the PostAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostActionMutation) OldPostID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostID: %w", err)
	}
	return oldValue.PostID, nil
}

// ResetPostID resets all changes to the "post_id" field.
func (m *PostActionMutation) ResetPostID() {
	m.post = nil
}

// SetActionType sets the "action_type" field.
func (m *PostActionMutation) SetActionType(pt postaction.ActionType) {
	m.action_type = &pt
}

// ActionType returns the value of the "action_type" field in the mutation.
func (m *PostActionMutation) ActionType() (r postaction.ActionType, exists bool) {
	v := m.action_type
	if v == nil {
		return
	}
	return *v, true
}

// OldActionType returns the old "action_type" field's value of the PostAction entity.
// If the PostAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostActionMutation) OldActionType(ctx context.Context) (v postaction.ActionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionType: %w", err)
	}
	return oldValue.ActionType, nil
}

// ResetActionType resets all changes to the "action_type" field.
func (m *PostActionMutation) ResetActionType() {
	m.action_type = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *PostActionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[postaction.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PostActionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PostActionMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PostActionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearPost clears the "post" edge to the Post entity.
func (m *PostActionMutation) ClearPost() {
	m.clearedpost = true
	m.clearedFields[postaction.FieldPostID] = struct{}{}
}

// PostCleared reports if the "post" edge to the Post entity was cleared.
func (m *PostActionMutation) PostCleared() bool {
	return m.clearedpost
}

// PostIDs returns the "post" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PostID instead. It exists only for internal usage by the builders.
func (m *PostActionMutation) PostIDs() (ids []int) {
	if id := m.post; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPost resets all changes to the "post" edge.
func (m *PostActionMutation) ResetPost() {
	m.post = nil
	m.clearedpost = false
}

// Where appends a list predicates to the PostActionMutation builder.
func (m *PostActionMutation) Where(ps ...predicate.PostAction) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PostActionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PostActionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PostAction, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PostActionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PostActionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PostAction).
func (m *PostActionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PostActionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, postaction.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, postaction.FieldUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, postaction.FieldUserID)
	}
	if m.post != nil {
		fields = append(fields, postaction.FieldPostID)
	}
	if m.action_type != nil {
		fields = append(fields, postaction.FieldActionType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PostActionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case postaction.FieldCreatedAt:
		return m.CreatedAt()
	case postaction.FieldUpdatedAt:
		return m.UpdatedAt()
	case postaction.FieldUserID:
		return m.UserID()
	case postaction.FieldPostID:
		return m.PostID()
	case postaction.FieldActionType:
		return m.ActionType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PostActionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case postaction.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case postaction.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case postaction.FieldUserID:
		return m.OldUserID(ctx)
	case postaction.FieldPostID:
		return m.OldPostID(ctx)
	case postaction.FieldActionType:
		return m.OldActionType(ctx)
	}
	return nil, fmt.Errorf("unknown PostAction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostActionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case postaction.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case postaction.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case postaction.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case postaction.FieldPostID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostID(v)
		return nil
	case postaction.FieldActionType:
		v, ok := value.(postaction.ActionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionType(v)
		return nil
	}
	return fmt.Errorf("unknown PostAction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PostActionMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PostActionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostActionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PostAction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PostActionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PostActionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PostActionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PostAction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PostActionMutation) ResetField(name string) error {
	switch name {
	case postaction.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case postaction.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case postaction.FieldUserID:
		m.ResetUserID()
		return nil
	case postaction.FieldPostID:
		m.ResetPostID()
		return nil
	case postaction.FieldActionType:
		m.ResetActionType()
		return nil
	}
	return fmt.Errorf("unknown PostAction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PostActionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, postaction.EdgeUser)
	}
	if m.post != nil {
		edges = append(edges, postaction.EdgePost)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PostActionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case postaction.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case postaction.EdgePost:
		if id := m.post; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PostActionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PostActionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PostActionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, postaction.EdgeUser)
	}
	if m.clearedpost {
		edges = append(edges, postaction.EdgePost)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PostActionMutation) EdgeCleared(name string) bool {
	switch name {
	case postaction.EdgeUser:
		return m.cleareduser
	case postaction.EdgePost:
		return m.clearedpost
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PostActionMutation) ClearEdge(name string) error {
	switch name {
	case postaction.EdgeUser:
		m.ClearUser()
		return nil
	case postaction.EdgePost:
		m.ClearPost()
		return nil
	}
	return fmt.Errorf("unknown PostAction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PostActionMutation) ResetEdge(name string) error {
	switch name {
	case postaction.EdgeUser:
		m.ResetUser()
		return nil
	case postaction.EdgePost:
		m.ResetPost()
		return nil
	}
	return fmt.Errorf("unknown PostAction edge %s", name)
}

// SettingsMutation represents an operation that mutates the Settings nodes in the graph.
type SettingsMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	module        *settings.Module
	key           *string
	value         *string
	value_type    *settings.ValueType
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Settings, error)
	predicates    []predicate.Settings
}

var _ ent.Mutation = (*SettingsMutation)(nil)

// settingsOption allows management of the mutation configuration using functional options.
type settingsOption func(*SettingsMutation)

// newSettingsMutation creates new mutation for the Settings entity.
func newSettingsMutation(c config, op Op, opts ...settingsOption) *SettingsMutation {
	m := &SettingsMutation{
		config:        c,
		op:            op,
		typ:           TypeSettings,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSettingsID sets the ID field of the mutation.
func withSettingsID(id int) settingsOption {
	return func(m *SettingsMutation) {
		var (
			err   error
			once  sync.Once
			value *Settings
		)
		m.oldValue = func(ctx context.Context) (*Settings, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Settings.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSettings sets the old Settings of the mutation.
func withSettings(node *Settings) settingsOption {
	return func(m *SettingsMutation) {
		m.oldValue = func(context.Context) (*Settings, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SettingsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SettingsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Settings entities.
func (m *SettingsMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SettingsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SettingsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Settings.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SettingsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SettingsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SettingsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SettingsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SettingsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SettingsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetModule sets the "module" field.
func (m *SettingsMutation) SetModule(s settings.Module) {
	m.module = &s
}

// Module returns the value of the "module" field in the mutation.
func (m *SettingsMutation) Module() (r settings.Module, exists bool) {
	v := m.module
	if v == nil {
		return
	}
	return *v, true
}

// OldModule returns the old "module" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldModule(ctx context.Context) (v settings.Module, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModule is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModule requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModule: %w", err)
	}
	return oldValue.Module, nil
}

// ResetModule resets all changes to the "module" field.
func (m *SettingsMutation) ResetModule() {
	m.module = nil
}

// SetKey sets the "key" field.
func (m *SettingsMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *SettingsMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *SettingsMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *SettingsMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *SettingsMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ClearValue clears the value of the "value" field.
func (m *SettingsMutation) ClearValue() {
	m.value = nil
	m.clearedFields[settings.FieldValue] = struct{}{}
}

// ValueCleared returns if the "value" field was cleared in this mutation.
func (m *SettingsMutation) ValueCleared() bool {
	_, ok := m.clearedFields[settings.FieldValue]
	return ok
}

// ResetValue resets all changes to the "value" field.
func (m *SettingsMutation) ResetValue() {
	m.value = nil
	delete(m.clearedFields, settings.FieldValue)
}

// SetValueType sets the "value_type" field.
func (m *SettingsMutation) SetValueType(st settings.ValueType) {
	m.value_type = &st
}

// ValueType returns the value of the "value_type" field in the mutation.
func (m *SettingsMutation) ValueType() (r settings.ValueType, exists bool) {
	v := m.value_type
	if v == nil {
		return
	}
	return *v, true
}

// OldValueType returns the old "value_type" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldValueType(ctx context.Context) (v settings.ValueType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValueType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValueType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValueType: %w", err)
	}
	return oldValue.ValueType, nil
}

// ResetValueType resets all changes to the "value_type" field.
func (m *SettingsMutation) ResetValueType() {
	m.value_type = nil
}

// Where appends a list predicates to the SettingsMutation builder.
func (m *SettingsMutation) Where(ps ...predicate.Settings) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SettingsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SettingsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Settings, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SettingsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SettingsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Settings).
func (m *SettingsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SettingsMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, settings.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, settings.FieldUpdatedAt)
	}
	if m.module != nil {
		fields = append(fields, settings.FieldModule)
	}
	if m.key != nil {
		fields = append(fields, settings.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, settings.FieldValue)
	}
	if m.value_type != nil {
		fields = append(fields, settings.FieldValueType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SettingsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case settings.FieldCreatedAt:
		return m.CreatedAt()
	case settings.FieldUpdatedAt:
		return m.UpdatedAt()
	case settings.FieldModule:
		return m.Module()
	case settings.FieldKey:
		return m.Key()
	case settings.FieldValue:
		return m.Value()
	case settings.FieldValueType:
		return m.ValueType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SettingsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case settings.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case settings.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case settings.FieldModule:
		return m.OldModule(ctx)
	case settings.FieldKey:
		return m.OldKey(ctx)
	case settings.FieldValue:
		return m.OldValue(ctx)
	case settings.FieldValueType:
		return m.OldValueType(ctx)
	}
	return nil, fmt.Errorf("unknown Settings field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case settings.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case settings.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case settings.FieldModule:
		v, ok := value.(settings.Module)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModule(v)
		return nil
	case settings.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case settings.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case settings.FieldValueType:
		v, ok := value.(settings.ValueType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValueType(v)
		return nil
	}
	return fmt.Errorf("unknown Settings field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SettingsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SettingsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Settings numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SettingsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(settings.FieldValue) {
		fields = append(fields, settings.FieldValue)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SettingsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SettingsMutation) ClearField(name string) error {
	switch name {
	case settings.FieldValue:
		m.ClearValue()
		return nil
	}
	return fmt.Errorf("unknown Settings nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SettingsMutation) ResetField(name string) error {
	switch name {
	case settings.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case settings.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case settings.FieldModule:
		m.ResetModule()
		return nil
	case settings.FieldKey:
		m.ResetKey()
		return nil
	case settings.FieldValue:
		m.ResetValue()
		return nil
	case settings.FieldValueType:
		m.ResetValueType()
		return nil
	}
	return fmt.Errorf("unknown Settings field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SettingsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SettingsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SettingsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SettingsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SettingsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SettingsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SettingsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Settings unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SettingsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Settings edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	created_at                *time.Time
	updated_at                *time.Time
	email                     *string
	password                  *string
	password_salt             *string
	username                  *string
	avatar                    *string
	signature                 *string
	readme                    *string
	email_verified            *bool
	points                    *int
	addpoints                 *int
	currency                  *int
	addcurrency               *int
	post_count                *int
	addpost_count             *int
	comment_count             *int
	addcomment_count          *int
	status                    *user.Status
	role                      *user.Role
	clearedFields             map[string]struct{}
	managed_categories        map[int]struct{}
	removedmanaged_categories map[int]struct{}
	clearedmanaged_categories bool
	balance_logs              map[int]struct{}
	removedbalance_logs       map[int]struct{}
	clearedbalance_logs       bool
	done                      bool
	oldValue                  func(context.Context) (*User, error)
	predicates                []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetPasswordSalt sets the "password_salt" field.
func (m *UserMutation) SetPasswordSalt(s string) {
	m.password_salt = &s
}

// PasswordSalt returns the value of the "password_salt" field in the mutation.
func (m *UserMutation) PasswordSalt() (r string, exists bool) {
	v := m.password_salt
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordSalt returns the old "password_salt" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordSalt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordSalt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordSalt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordSalt: %w", err)
	}
	return oldValue.PasswordSalt, nil
}

// ResetPasswordSalt resets all changes to the "password_salt" field.
func (m *UserMutation) ResetPasswordSalt() {
	m.password_salt = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetAvatar sets the "avatar" field.
func (m *UserMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *UserMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of the "avatar" field.
func (m *UserMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[user.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the "avatar" field was cleared in this mutation.
func (m *UserMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatar]
	return ok
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *UserMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, user.FieldAvatar)
}

// SetSignature sets the "signature" field.
func (m *UserMutation) SetSignature(s string) {
	m.signature = &s
}

// Signature returns the value of the "signature" field in the mutation.
func (m *UserMutation) Signature() (r string, exists bool) {
	v := m.signature
	if v == nil {
		return
	}
	return *v, true
}

// OldSignature returns the old "signature" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSignature(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignature: %w", err)
	}
	return oldValue.Signature, nil
}

// ClearSignature clears the value of the "signature" field.
func (m *UserMutation) ClearSignature() {
	m.signature = nil
	m.clearedFields[user.FieldSignature] = struct{}{}
}

// SignatureCleared returns if the "signature" field was cleared in this mutation.
func (m *UserMutation) SignatureCleared() bool {
	_, ok := m.clearedFields[user.FieldSignature]
	return ok
}

// ResetSignature resets all changes to the "signature" field.
func (m *UserMutation) ResetSignature() {
	m.signature = nil
	delete(m.clearedFields, user.FieldSignature)
}

// SetReadme sets the "readme" field.
func (m *UserMutation) SetReadme(s string) {
	m.readme = &s
}

// Readme returns the value of the "readme" field in the mutation.
func (m *UserMutation) Readme() (r string, exists bool) {
	v := m.readme
	if v == nil {
		return
	}
	return *v, true
}

// OldReadme returns the old "readme" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldReadme(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReadme is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReadme requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReadme: %w", err)
	}
	return oldValue.Readme, nil
}

// ClearReadme clears the value of the "readme" field.
func (m *UserMutation) ClearReadme() {
	m.readme = nil
	m.clearedFields[user.FieldReadme] = struct{}{}
}

// ReadmeCleared returns if the "readme" field was cleared in this mutation.
func (m *UserMutation) ReadmeCleared() bool {
	_, ok := m.clearedFields[user.FieldReadme]
	return ok
}

// ResetReadme resets all changes to the "readme" field.
func (m *UserMutation) ResetReadme() {
	m.readme = nil
	delete(m.clearedFields, user.FieldReadme)
}

// SetEmailVerified sets the "email_verified" field.
func (m *UserMutation) SetEmailVerified(b bool) {
	m.email_verified = &b
}

// EmailVerified returns the value of the "email_verified" field in the mutation.
func (m *UserMutation) EmailVerified() (r bool, exists bool) {
	v := m.email_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailVerified returns the old "email_verified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmailVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailVerified: %w", err)
	}
	return oldValue.EmailVerified, nil
}

// ResetEmailVerified resets all changes to the "email_verified" field.
func (m *UserMutation) ResetEmailVerified() {
	m.email_verified = nil
}

// SetPoints sets the "points" field.
func (m *UserMutation) SetPoints(i int) {
	m.points = &i
	m.addpoints = nil
}

// Points returns the value of the "points" field in the mutation.
func (m *UserMutation) Points() (r int, exists bool) {
	v := m.points
	if v == nil {
		return
	}
	return *v, true
}

// OldPoints returns the old "points" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPoints(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoints is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoints requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoints: %w", err)
	}
	return oldValue.Points, nil
}

// AddPoints adds i to the "points" field.
func (m *UserMutation) AddPoints(i int) {
	if m.addpoints != nil {
		*m.addpoints += i
	} else {
		m.addpoints = &i
	}
}

// AddedPoints returns the value that was added to the "points" field in this mutation.
func (m *UserMutation) AddedPoints() (r int, exists bool) {
	v := m.addpoints
	if v == nil {
		return
	}
	return *v, true
}

// ResetPoints resets all changes to the "points" field.
func (m *UserMutation) ResetPoints() {
	m.points = nil
	m.addpoints = nil
}

// SetCurrency sets the "currency" field.
func (m *UserMutation) SetCurrency(i int) {
	m.currency = &i
	m.addcurrency = nil
}

// Currency returns the value of the "currency" field in the mutation.
func (m *UserMutation) Currency() (r int, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCurrency(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// AddCurrency adds i to the "currency" field.
func (m *UserMutation) AddCurrency(i int) {
	if m.addcurrency != nil {
		*m.addcurrency += i
	} else {
		m.addcurrency = &i
	}
}

// AddedCurrency returns the value that was added to the "currency" field in this mutation.
func (m *UserMutation) AddedCurrency() (r int, exists bool) {
	v := m.addcurrency
	if v == nil {
		return
	}
	return *v, true
}

// ResetCurrency resets all changes to the "currency" field.
func (m *UserMutation) ResetCurrency() {
	m.currency = nil
	m.addcurrency = nil
}

// SetPostCount sets the "post_count" field.
func (m *UserMutation) SetPostCount(i int) {
	m.post_count = &i
	m.addpost_count = nil
}

// PostCount returns the value of the "post_count" field in the mutation.
func (m *UserMutation) PostCount() (r int, exists bool) {
	v := m.post_count
	if v == nil {
		return
	}
	return *v, true
}

// OldPostCount returns the old "post_count" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPostCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostCount: %w", err)
	}
	return oldValue.PostCount, nil
}

// AddPostCount adds i to the "post_count" field.
func (m *UserMutation) AddPostCount(i int) {
	if m.addpost_count != nil {
		*m.addpost_count += i
	} else {
		m.addpost_count = &i
	}
}

// AddedPostCount returns the value that was added to the "post_count" field in this mutation.
func (m *UserMutation) AddedPostCount() (r int, exists bool) {
	v := m.addpost_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetPostCount resets all changes to the "post_count" field.
func (m *UserMutation) ResetPostCount() {
	m.post_count = nil
	m.addpost_count = nil
}

// SetCommentCount sets the "comment_count" field.
func (m *UserMutation) SetCommentCount(i int) {
	m.comment_count = &i
	m.addcomment_count = nil
}

// CommentCount returns the value of the "comment_count" field in the mutation.
func (m *UserMutation) CommentCount() (r int, exists bool) {
	v := m.comment_count
	if v == nil {
		return
	}
	return *v, true
}

// OldCommentCount returns the old "comment_count" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCommentCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommentCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommentCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommentCount: %w", err)
	}
	return oldValue.CommentCount, nil
}

// AddCommentCount adds i to the "comment_count" field.
func (m *UserMutation) AddCommentCount(i int) {
	if m.addcomment_count != nil {
		*m.addcomment_count += i
	} else {
		m.addcomment_count = &i
	}
}

// AddedCommentCount returns the value that was added to the "comment_count" field in this mutation.
func (m *UserMutation) AddedCommentCount() (r int, exists bool) {
	v := m.addcomment_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetCommentCount resets all changes to the "comment_count" field.
func (m *UserMutation) ResetCommentCount() {
	m.comment_count = nil
	m.addcomment_count = nil
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(u user.Status) {
	m.status = &u
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r user.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v user.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(u user.Role) {
	m.role = &u
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r user.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v user.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
}

// AddManagedCategoryIDs adds the "managed_categories" edge to the Category entity by ids.
func (m *UserMutation) AddManagedCategoryIDs(ids ...int) {
	if m.managed_categories == nil {
		m.managed_categories = make(map[int]struct{})
	}
	for i := range ids {
		m.managed_categories[ids[i]] = struct{}{}
	}
}

// ClearManagedCategories clears the "managed_categories" edge to the Category entity.
func (m *UserMutation) ClearManagedCategories() {
	m.clearedmanaged_categories = true
}

// ManagedCategoriesCleared reports if the "managed_categories" edge to the Category entity was cleared.
func (m *UserMutation) ManagedCategoriesCleared() bool {
	return m.clearedmanaged_categories
}

// RemoveManagedCategoryIDs removes the "managed_categories" edge to the Category entity by IDs.
func (m *UserMutation) RemoveManagedCategoryIDs(ids ...int) {
	if m.removedmanaged_categories == nil {
		m.removedmanaged_categories = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.managed_categories, ids[i])
		m.removedmanaged_categories[ids[i]] = struct{}{}
	}
}

// RemovedManagedCategories returns the removed IDs of the "managed_categories" edge to the Category entity.
func (m *UserMutation) RemovedManagedCategoriesIDs() (ids []int) {
	for id := range m.removedmanaged_categories {
		ids = append(ids, id)
	}
	return
}

// ManagedCategoriesIDs returns the "managed_categories" edge IDs in the mutation.
func (m *UserMutation) ManagedCategoriesIDs() (ids []int) {
	for id := range m.managed_categories {
		ids = append(ids, id)
	}
	return
}

// ResetManagedCategories resets all changes to the "managed_categories" edge.
func (m *UserMutation) ResetManagedCategories() {
	m.managed_categories = nil
	m.clearedmanaged_categories = false
	m.removedmanaged_categories = nil
}

// AddBalanceLogIDs adds the "balance_logs" edge to the UserBalanceLog entity by ids.
func (m *UserMutation) AddBalanceLogIDs(ids ...int) {
	if m.balance_logs == nil {
		m.balance_logs = make(map[int]struct{})
	}
	for i := range ids {
		m.balance_logs[ids[i]] = struct{}{}
	}
}

// ClearBalanceLogs clears the "balance_logs" edge to the UserBalanceLog entity.
func (m *UserMutation) ClearBalanceLogs() {
	m.clearedbalance_logs = true
}

// BalanceLogsCleared reports if the "balance_logs" edge to the UserBalanceLog entity was cleared.
func (m *UserMutation) BalanceLogsCleared() bool {
	return m.clearedbalance_logs
}

// RemoveBalanceLogIDs removes the "balance_logs" edge to the UserBalanceLog entity by IDs.
func (m *UserMutation) RemoveBalanceLogIDs(ids ...int) {
	if m.removedbalance_logs == nil {
		m.removedbalance_logs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.balance_logs, ids[i])
		m.removedbalance_logs[ids[i]] = struct{}{}
	}
}

// RemovedBalanceLogs returns the removed IDs of the "balance_logs" edge to the UserBalanceLog entity.
func (m *UserMutation) RemovedBalanceLogsIDs() (ids []int) {
	for id := range m.removedbalance_logs {
		ids = append(ids, id)
	}
	return
}

// BalanceLogsIDs returns the "balance_logs" edge IDs in the mutation.
func (m *UserMutation) BalanceLogsIDs() (ids []int) {
	for id := range m.balance_logs {
		ids = append(ids, id)
	}
	return
}

// ResetBalanceLogs resets all changes to the "balance_logs" edge.
func (m *UserMutation) ResetBalanceLogs() {
	m.balance_logs = nil
	m.clearedbalance_logs = false
	m.removedbalance_logs = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.password_salt != nil {
		fields = append(fields, user.FieldPasswordSalt)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.avatar != nil {
		fields = append(fields, user.FieldAvatar)
	}
	if m.signature != nil {
		fields = append(fields, user.FieldSignature)
	}
	if m.readme != nil {
		fields = append(fields, user.FieldReadme)
	}
	if m.email_verified != nil {
		fields = append(fields, user.FieldEmailVerified)
	}
	if m.points != nil {
		fields = append(fields, user.FieldPoints)
	}
	if m.currency != nil {
		fields = append(fields, user.FieldCurrency)
	}
	if m.post_count != nil {
		fields = append(fields, user.FieldPostCount)
	}
	if m.comment_count != nil {
		fields = append(fields, user.FieldCommentCount)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPassword:
		return m.Password()
	case user.FieldPasswordSalt:
		return m.PasswordSalt()
	case user.FieldUsername:
		return m.Username()
	case user.FieldAvatar:
		return m.Avatar()
	case user.FieldSignature:
		return m.Signature()
	case user.FieldReadme:
		return m.Readme()
	case user.FieldEmailVerified:
		return m.EmailVerified()
	case user.FieldPoints:
		return m.Points()
	case user.FieldCurrency:
		return m.Currency()
	case user.FieldPostCount:
		return m.PostCount()
	case user.FieldCommentCount:
		return m.CommentCount()
	case user.FieldStatus:
		return m.Status()
	case user.FieldRole:
		return m.Role()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldPasswordSalt:
		return m.OldPasswordSalt(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldAvatar:
		return m.OldAvatar(ctx)
	case user.FieldSignature:
		return m.OldSignature(ctx)
	case user.FieldReadme:
		return m.OldReadme(ctx)
	case user.FieldEmailVerified:
		return m.OldEmailVerified(ctx)
	case user.FieldPoints:
		return m.OldPoints(ctx)
	case user.FieldCurrency:
		return m.OldCurrency(ctx)
	case user.FieldPostCount:
		return m.OldPostCount(ctx)
	case user.FieldCommentCount:
		return m.OldCommentCount(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldPasswordSalt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordSalt(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case user.FieldSignature:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignature(v)
		return nil
	case user.FieldReadme:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReadme(v)
		return nil
	case user.FieldEmailVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailVerified(v)
		return nil
	case user.FieldPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoints(v)
		return nil
	case user.FieldCurrency:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case user.FieldPostCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostCount(v)
		return nil
	case user.FieldCommentCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommentCount(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(user.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldRole:
		v, ok := value.(user.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addpoints != nil {
		fields = append(fields, user.FieldPoints)
	}
	if m.addcurrency != nil {
		fields = append(fields, user.FieldCurrency)
	}
	if m.addpost_count != nil {
		fields = append(fields, user.FieldPostCount)
	}
	if m.addcomment_count != nil {
		fields = append(fields, user.FieldCommentCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldPoints:
		return m.AddedPoints()
	case user.FieldCurrency:
		return m.AddedCurrency()
	case user.FieldPostCount:
		return m.AddedPostCount()
	case user.FieldCommentCount:
		return m.AddedCommentCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPoints(v)
		return nil
	case user.FieldCurrency:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCurrency(v)
		return nil
	case user.FieldPostCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPostCount(v)
		return nil
	case user.FieldCommentCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCommentCount(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldAvatar) {
		fields = append(fields, user.FieldAvatar)
	}
	if m.FieldCleared(user.FieldSignature) {
		fields = append(fields, user.FieldSignature)
	}
	if m.FieldCleared(user.FieldReadme) {
		fields = append(fields, user.FieldReadme)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldAvatar:
		m.ClearAvatar()
		return nil
	case user.FieldSignature:
		m.ClearSignature()
		return nil
	case user.FieldReadme:
		m.ClearReadme()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldPasswordSalt:
		m.ResetPasswordSalt()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldAvatar:
		m.ResetAvatar()
		return nil
	case user.FieldSignature:
		m.ResetSignature()
		return nil
	case user.FieldReadme:
		m.ResetReadme()
		return nil
	case user.FieldEmailVerified:
		m.ResetEmailVerified()
		return nil
	case user.FieldPoints:
		m.ResetPoints()
		return nil
	case user.FieldCurrency:
		m.ResetCurrency()
		return nil
	case user.FieldPostCount:
		m.ResetPostCount()
		return nil
	case user.FieldCommentCount:
		m.ResetCommentCount()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.managed_categories != nil {
		edges = append(edges, user.EdgeManagedCategories)
	}
	if m.balance_logs != nil {
		edges = append(edges, user.EdgeBalanceLogs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeManagedCategories:
		ids := make([]ent.Value, 0, len(m.managed_categories))
		for id := range m.managed_categories {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBalanceLogs:
		ids := make([]ent.Value, 0, len(m.balance_logs))
		for id := range m.balance_logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmanaged_categories != nil {
		edges = append(edges, user.EdgeManagedCategories)
	}
	if m.removedbalance_logs != nil {
		edges = append(edges, user.EdgeBalanceLogs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeManagedCategories:
		ids := make([]ent.Value, 0, len(m.removedmanaged_categories))
		for id := range m.removedmanaged_categories {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBalanceLogs:
		ids := make([]ent.Value, 0, len(m.removedbalance_logs))
		for id := range m.removedbalance_logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmanaged_categories {
		edges = append(edges, user.EdgeManagedCategories)
	}
	if m.clearedbalance_logs {
		edges = append(edges, user.EdgeBalanceLogs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeManagedCategories:
		return m.clearedmanaged_categories
	case user.EdgeBalanceLogs:
		return m.clearedbalance_logs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeManagedCategories:
		m.ResetManagedCategories()
		return nil
	case user.EdgeBalanceLogs:
		m.ResetBalanceLogs()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserBalanceLogMutation represents an operation that mutates the UserBalanceLog nodes in the graph.
type UserBalanceLogMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_at       *time.Time
	updated_at       *time.Time
	_type            *userbalancelog.Type
	amount           *int
	addamount        *int
	before_amount    *int
	addbefore_amount *int
	after_amount     *int
	addafter_amount  *int
	reason           *string
	operator_id      *int
	addoperator_id   *int
	operator_name    *string
	related_id       *int
	addrelated_id    *int
	related_type     *string
	ip_address       *string
	user_agent       *string
	clearedFields    map[string]struct{}
	user             *int
	cleareduser      bool
	done             bool
	oldValue         func(context.Context) (*UserBalanceLog, error)
	predicates       []predicate.UserBalanceLog
}

var _ ent.Mutation = (*UserBalanceLogMutation)(nil)

// userbalancelogOption allows management of the mutation configuration using functional options.
type userbalancelogOption func(*UserBalanceLogMutation)

// newUserBalanceLogMutation creates new mutation for the UserBalanceLog entity.
func newUserBalanceLogMutation(c config, op Op, opts ...userbalancelogOption) *UserBalanceLogMutation {
	m := &UserBalanceLogMutation{
		config:        c,
		op:            op,
		typ:           TypeUserBalanceLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserBalanceLogID sets the ID field of the mutation.
func withUserBalanceLogID(id int) userbalancelogOption {
	return func(m *UserBalanceLogMutation) {
		var (
			err   error
			once  sync.Once
			value *UserBalanceLog
		)
		m.oldValue = func(ctx context.Context) (*UserBalanceLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserBalanceLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserBalanceLog sets the old UserBalanceLog of the mutation.
func withUserBalanceLog(node *UserBalanceLog) userbalancelogOption {
	return func(m *UserBalanceLogMutation) {
		m.oldValue = func(context.Context) (*UserBalanceLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserBalanceLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserBalanceLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserBalanceLog entities.
func (m *UserBalanceLogMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserBalanceLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserBalanceLogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserBalanceLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserBalanceLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserBalanceLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserBalanceLog entity.
// If the UserBalanceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBalanceLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserBalanceLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserBalanceLogMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserBalanceLogMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserBalanceLog entity.
// If the UserBalanceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBalanceLogMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserBalanceLogMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *UserBalanceLogMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserBalanceLogMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserBalanceLog entity.
// If the UserBalanceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBalanceLogMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserBalanceLogMutation) ResetUserID() {
	m.user = nil
}

// SetType sets the "type" field.
func (m *UserBalanceLogMutation) SetType(u userbalancelog.Type) {
	m._type = &u
}

// GetType returns the value of the "type" field in the mutation.
func (m *UserBalanceLogMutation) GetType() (r userbalancelog.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the UserBalanceLog entity.
// If the UserBalanceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBalanceLogMutation) OldType(ctx context.Context) (v userbalancelog.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *UserBalanceLogMutation) ResetType() {
	m._type = nil
}

// SetAmount sets the "amount" field.
func (m *UserBalanceLogMutation) SetAmount(i int) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *UserBalanceLogMutation) Amount() (r int, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the UserBalanceLog entity.
// If the UserBalanceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBalanceLogMutation) OldAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "amount" field.
func (m *UserBalanceLogMutation) AddAmount(i int) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *UserBalanceLogMutation) AddedAmount() (r int, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *UserBalanceLogMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetBeforeAmount sets the "before_amount" field.
func (m *UserBalanceLogMutation) SetBeforeAmount(i int) {
	m.before_amount = &i
	m.addbefore_amount = nil
}

// BeforeAmount returns the value of the "before_amount" field in the mutation.
func (m *UserBalanceLogMutation) BeforeAmount() (r int, exists bool) {
	v := m.before_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldBeforeAmount returns the old "before_amount" field's value of the UserBalanceLog entity.
// If the UserBalanceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBalanceLogMutation) OldBeforeAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBeforeAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBeforeAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBeforeAmount: %w", err)
	}
	return oldValue.BeforeAmount, nil
}

// AddBeforeAmount adds i to the "before_amount" field.
func (m *UserBalanceLogMutation) AddBeforeAmount(i int) {
	if m.addbefore_amount != nil {
		*m.addbefore_amount += i
	} else {
		m.addbefore_amount = &i
	}
}

// AddedBeforeAmount returns the value that was added to the "before_amount" field in this mutation.
func (m *UserBalanceLogMutation) AddedBeforeAmount() (r int, exists bool) {
	v := m.addbefore_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetBeforeAmount resets all changes to the "before_amount" field.
func (m *UserBalanceLogMutation) ResetBeforeAmount() {
	m.before_amount = nil
	m.addbefore_amount = nil
}

// SetAfterAmount sets the "after_amount" field.
func (m *UserBalanceLogMutation) SetAfterAmount(i int) {
	m.after_amount = &i
	m.addafter_amount = nil
}

// AfterAmount returns the value of the "after_amount" field in the mutation.
func (m *UserBalanceLogMutation) AfterAmount() (r int, exists bool) {
	v := m.after_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAfterAmount returns the old "after_amount" field's value of the UserBalanceLog entity.
// If the UserBalanceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBalanceLogMutation) OldAfterAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAfterAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAfterAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAfterAmount: %w", err)
	}
	return oldValue.AfterAmount, nil
}

// AddAfterAmount adds i to the "after_amount" field.
func (m *UserBalanceLogMutation) AddAfterAmount(i int) {
	if m.addafter_amount != nil {
		*m.addafter_amount += i
	} else {
		m.addafter_amount = &i
	}
}

// AddedAfterAmount returns the value that was added to the "after_amount" field in this mutation.
func (m *UserBalanceLogMutation) AddedAfterAmount() (r int, exists bool) {
	v := m.addafter_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAfterAmount resets all changes to the "after_amount" field.
func (m *UserBalanceLogMutation) ResetAfterAmount() {
	m.after_amount = nil
	m.addafter_amount = nil
}

// SetReason sets the "reason" field.
func (m *UserBalanceLogMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *UserBalanceLogMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the UserBalanceLog entity.
// If the UserBalanceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBalanceLogMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ResetReason resets all changes to the "reason" field.
func (m *UserBalanceLogMutation) ResetReason() {
	m.reason = nil
}

// SetOperatorID sets the "operator_id" field.
func (m *UserBalanceLogMutation) SetOperatorID(i int) {
	m.operator_id = &i
	m.addoperator_id = nil
}

// OperatorID returns the value of the "operator_id" field in the mutation.
func (m *UserBalanceLogMutation) OperatorID() (r int, exists bool) {
	v := m.operator_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOperatorID returns the old "operator_id" field's value of the UserBalanceLog entity.
// If the UserBalanceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBalanceLogMutation) OldOperatorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperatorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperatorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperatorID: %w", err)
	}
	return oldValue.OperatorID, nil
}

// AddOperatorID adds i to the "operator_id" field.
func (m *UserBalanceLogMutation) AddOperatorID(i int) {
	if m.addoperator_id != nil {
		*m.addoperator_id += i
	} else {
		m.addoperator_id = &i
	}
}

// AddedOperatorID returns the value that was added to the "operator_id" field in this mutation.
func (m *UserBalanceLogMutation) AddedOperatorID() (r int, exists bool) {
	v := m.addoperator_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearOperatorID clears the value of the "operator_id" field.
func (m *UserBalanceLogMutation) ClearOperatorID() {
	m.operator_id = nil
	m.addoperator_id = nil
	m.clearedFields[userbalancelog.FieldOperatorID] = struct{}{}
}

// OperatorIDCleared returns if the "operator_id" field was cleared in this mutation.
func (m *UserBalanceLogMutation) OperatorIDCleared() bool {
	_, ok := m.clearedFields[userbalancelog.FieldOperatorID]
	return ok
}

// ResetOperatorID resets all changes to the "operator_id" field.
func (m *UserBalanceLogMutation) ResetOperatorID() {
	m.operator_id = nil
	m.addoperator_id = nil
	delete(m.clearedFields, userbalancelog.FieldOperatorID)
}

// SetOperatorName sets the "operator_name" field.
func (m *UserBalanceLogMutation) SetOperatorName(s string) {
	m.operator_name = &s
}

// OperatorName returns the value of the "operator_name" field in the mutation.
func (m *UserBalanceLogMutation) OperatorName() (r string, exists bool) {
	v := m.operator_name
	if v == nil {
		return
	}
	return *v, true
}

// OldOperatorName returns the old "operator_name" field's value of the UserBalanceLog entity.
// If the UserBalanceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBalanceLogMutation) OldOperatorName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperatorName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperatorName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperatorName: %w", err)
	}
	return oldValue.OperatorName, nil
}

// ClearOperatorName clears the value of the "operator_name" field.
func (m *UserBalanceLogMutation) ClearOperatorName() {
	m.operator_name = nil
	m.clearedFields[userbalancelog.FieldOperatorName] = struct{}{}
}

// OperatorNameCleared returns if the "operator_name" field was cleared in this mutation.
func (m *UserBalanceLogMutation) OperatorNameCleared() bool {
	_, ok := m.clearedFields[userbalancelog.FieldOperatorName]
	return ok
}

// ResetOperatorName resets all changes to the "operator_name" field.
func (m *UserBalanceLogMutation) ResetOperatorName() {
	m.operator_name = nil
	delete(m.clearedFields, userbalancelog.FieldOperatorName)
}

// SetRelatedID sets the "related_id" field.
func (m *UserBalanceLogMutation) SetRelatedID(i int) {
	m.related_id = &i
	m.addrelated_id = nil
}

// RelatedID returns the value of the "related_id" field in the mutation.
func (m *UserBalanceLogMutation) RelatedID() (r int, exists bool) {
	v := m.related_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRelatedID returns the old "related_id" field's value of the UserBalanceLog entity.
// If the UserBalanceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBalanceLogMutation) OldRelatedID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelatedID: %w", err)
	}
	return oldValue.RelatedID, nil
}

// AddRelatedID adds i to the "related_id" field.
func (m *UserBalanceLogMutation) AddRelatedID(i int) {
	if m.addrelated_id != nil {
		*m.addrelated_id += i
	} else {
		m.addrelated_id = &i
	}
}

// AddedRelatedID returns the value that was added to the "related_id" field in this mutation.
func (m *UserBalanceLogMutation) AddedRelatedID() (r int, exists bool) {
	v := m.addrelated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearRelatedID clears the value of the "related_id" field.
func (m *UserBalanceLogMutation) ClearRelatedID() {
	m.related_id = nil
	m.addrelated_id = nil
	m.clearedFields[userbalancelog.FieldRelatedID] = struct{}{}
}

// RelatedIDCleared returns if the "related_id" field was cleared in this mutation.
func (m *UserBalanceLogMutation) RelatedIDCleared() bool {
	_, ok := m.clearedFields[userbalancelog.FieldRelatedID]
	return ok
}

// ResetRelatedID resets all changes to the "related_id" field.
func (m *UserBalanceLogMutation) ResetRelatedID() {
	m.related_id = nil
	m.addrelated_id = nil
	delete(m.clearedFields, userbalancelog.FieldRelatedID)
}

// SetRelatedType sets the "related_type" field.
func (m *UserBalanceLogMutation) SetRelatedType(s string) {
	m.related_type = &s
}

// RelatedType returns the value of the "related_type" field in the mutation.
func (m *UserBalanceLogMutation) RelatedType() (r string, exists bool) {
	v := m.related_type
	if v == nil {
		return
	}
	return *v, true
}

// OldRelatedType returns the old "related_type" field's value of the UserBalanceLog entity.
// If the UserBalanceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBalanceLogMutation) OldRelatedType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelatedType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelatedType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelatedType: %w", err)
	}
	return oldValue.RelatedType, nil
}

// ClearRelatedType clears the value of the "related_type" field.
func (m *UserBalanceLogMutation) ClearRelatedType() {
	m.related_type = nil
	m.clearedFields[userbalancelog.FieldRelatedType] = struct{}{}
}

// RelatedTypeCleared returns if the "related_type" field was cleared in this mutation.
func (m *UserBalanceLogMutation) RelatedTypeCleared() bool {
	_, ok := m.clearedFields[userbalancelog.FieldRelatedType]
	return ok
}

// ResetRelatedType resets all changes to the "related_type" field.
func (m *UserBalanceLogMutation) ResetRelatedType() {
	m.related_type = nil
	delete(m.clearedFields, userbalancelog.FieldRelatedType)
}

// SetIPAddress sets the "ip_address" field.
func (m *UserBalanceLogMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *UserBalanceLogMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the UserBalanceLog entity.
// If the UserBalanceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBalanceLogMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *UserBalanceLogMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[userbalancelog.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *UserBalanceLogMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[userbalancelog.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *UserBalanceLogMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, userbalancelog.FieldIPAddress)
}

// SetUserAgent sets the "user_agent" field.
func (m *UserBalanceLogMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *UserBalanceLogMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the UserBalanceLog entity.
// If the UserBalanceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBalanceLogMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *UserBalanceLogMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[userbalancelog.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *UserBalanceLogMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[userbalancelog.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *UserBalanceLogMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, userbalancelog.FieldUserAgent)
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserBalanceLogMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userbalancelog.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserBalanceLogMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserBalanceLogMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserBalanceLogMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserBalanceLogMutation builder.
func (m *UserBalanceLogMutation) Where(ps ...predicate.UserBalanceLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserBalanceLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserBalanceLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserBalanceLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserBalanceLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserBalanceLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserBalanceLog).
func (m *UserBalanceLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserBalanceLogMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, userbalancelog.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userbalancelog.FieldUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, userbalancelog.FieldUserID)
	}
	if m._type != nil {
		fields = append(fields, userbalancelog.FieldType)
	}
	if m.amount != nil {
		fields = append(fields, userbalancelog.FieldAmount)
	}
	if m.before_amount != nil {
		fields = append(fields, userbalancelog.FieldBeforeAmount)
	}
	if m.after_amount != nil {
		fields = append(fields, userbalancelog.FieldAfterAmount)
	}
	if m.reason != nil {
		fields = append(fields, userbalancelog.FieldReason)
	}
	if m.operator_id != nil {
		fields = append(fields, userbalancelog.FieldOperatorID)
	}
	if m.operator_name != nil {
		fields = append(fields, userbalancelog.FieldOperatorName)
	}
	if m.related_id != nil {
		fields = append(fields, userbalancelog.FieldRelatedID)
	}
	if m.related_type != nil {
		fields = append(fields, userbalancelog.FieldRelatedType)
	}
	if m.ip_address != nil {
		fields = append(fields, userbalancelog.FieldIPAddress)
	}
	if m.user_agent != nil {
		fields = append(fields, userbalancelog.FieldUserAgent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserBalanceLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userbalancelog.FieldCreatedAt:
		return m.CreatedAt()
	case userbalancelog.FieldUpdatedAt:
		return m.UpdatedAt()
	case userbalancelog.FieldUserID:
		return m.UserID()
	case userbalancelog.FieldType:
		return m.GetType()
	case userbalancelog.FieldAmount:
		return m.Amount()
	case userbalancelog.FieldBeforeAmount:
		return m.BeforeAmount()
	case userbalancelog.FieldAfterAmount:
		return m.AfterAmount()
	case userbalancelog.FieldReason:
		return m.Reason()
	case userbalancelog.FieldOperatorID:
		return m.OperatorID()
	case userbalancelog.FieldOperatorName:
		return m.OperatorName()
	case userbalancelog.FieldRelatedID:
		return m.RelatedID()
	case userbalancelog.FieldRelatedType:
		return m.RelatedType()
	case userbalancelog.FieldIPAddress:
		return m.IPAddress()
	case userbalancelog.FieldUserAgent:
		return m.UserAgent()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserBalanceLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userbalancelog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userbalancelog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userbalancelog.FieldUserID:
		return m.OldUserID(ctx)
	case userbalancelog.FieldType:
		return m.OldType(ctx)
	case userbalancelog.FieldAmount:
		return m.OldAmount(ctx)
	case userbalancelog.FieldBeforeAmount:
		return m.OldBeforeAmount(ctx)
	case userbalancelog.FieldAfterAmount:
		return m.OldAfterAmount(ctx)
	case userbalancelog.FieldReason:
		return m.OldReason(ctx)
	case userbalancelog.FieldOperatorID:
		return m.OldOperatorID(ctx)
	case userbalancelog.FieldOperatorName:
		return m.OldOperatorName(ctx)
	case userbalancelog.FieldRelatedID:
		return m.OldRelatedID(ctx)
	case userbalancelog.FieldRelatedType:
		return m.OldRelatedType(ctx)
	case userbalancelog.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case userbalancelog.FieldUserAgent:
		return m.OldUserAgent(ctx)
	}
	return nil, fmt.Errorf("unknown UserBalanceLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserBalanceLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userbalancelog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userbalancelog.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userbalancelog.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userbalancelog.FieldType:
		v, ok := value.(userbalancelog.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case userbalancelog.FieldAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case userbalancelog.FieldBeforeAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBeforeAmount(v)
		return nil
	case userbalancelog.FieldAfterAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAfterAmount(v)
		return nil
	case userbalancelog.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case userbalancelog.FieldOperatorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperatorID(v)
		return nil
	case userbalancelog.FieldOperatorName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperatorName(v)
		return nil
	case userbalancelog.FieldRelatedID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelatedID(v)
		return nil
	case userbalancelog.FieldRelatedType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelatedType(v)
		return nil
	case userbalancelog.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case userbalancelog.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	}
	return fmt.Errorf("unknown UserBalanceLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserBalanceLogMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, userbalancelog.FieldAmount)
	}
	if m.addbefore_amount != nil {
		fields = append(fields, userbalancelog.FieldBeforeAmount)
	}
	if m.addafter_amount != nil {
		fields = append(fields, userbalancelog.FieldAfterAmount)
	}
	if m.addoperator_id != nil {
		fields = append(fields, userbalancelog.FieldOperatorID)
	}
	if m.addrelated_id != nil {
		fields = append(fields, userbalancelog.FieldRelatedID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserBalanceLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userbalancelog.FieldAmount:
		return m.AddedAmount()
	case userbalancelog.FieldBeforeAmount:
		return m.AddedBeforeAmount()
	case userbalancelog.FieldAfterAmount:
		return m.AddedAfterAmount()
	case userbalancelog.FieldOperatorID:
		return m.AddedOperatorID()
	case userbalancelog.FieldRelatedID:
		return m.AddedRelatedID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserBalanceLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userbalancelog.FieldAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case userbalancelog.FieldBeforeAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBeforeAmount(v)
		return nil
	case userbalancelog.FieldAfterAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAfterAmount(v)
		return nil
	case userbalancelog.FieldOperatorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOperatorID(v)
		return nil
	case userbalancelog.FieldRelatedID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRelatedID(v)
		return nil
	}
	return fmt.Errorf("unknown UserBalanceLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserBalanceLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userbalancelog.FieldOperatorID) {
		fields = append(fields, userbalancelog.FieldOperatorID)
	}
	if m.FieldCleared(userbalancelog.FieldOperatorName) {
		fields = append(fields, userbalancelog.FieldOperatorName)
	}
	if m.FieldCleared(userbalancelog.FieldRelatedID) {
		fields = append(fields, userbalancelog.FieldRelatedID)
	}
	if m.FieldCleared(userbalancelog.FieldRelatedType) {
		fields = append(fields, userbalancelog.FieldRelatedType)
	}
	if m.FieldCleared(userbalancelog.FieldIPAddress) {
		fields = append(fields, userbalancelog.FieldIPAddress)
	}
	if m.FieldCleared(userbalancelog.FieldUserAgent) {
		fields = append(fields, userbalancelog.FieldUserAgent)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserBalanceLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserBalanceLogMutation) ClearField(name string) error {
	switch name {
	case userbalancelog.FieldOperatorID:
		m.ClearOperatorID()
		return nil
	case userbalancelog.FieldOperatorName:
		m.ClearOperatorName()
		return nil
	case userbalancelog.FieldRelatedID:
		m.ClearRelatedID()
		return nil
	case userbalancelog.FieldRelatedType:
		m.ClearRelatedType()
		return nil
	case userbalancelog.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case userbalancelog.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	}
	return fmt.Errorf("unknown UserBalanceLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserBalanceLogMutation) ResetField(name string) error {
	switch name {
	case userbalancelog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userbalancelog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userbalancelog.FieldUserID:
		m.ResetUserID()
		return nil
	case userbalancelog.FieldType:
		m.ResetType()
		return nil
	case userbalancelog.FieldAmount:
		m.ResetAmount()
		return nil
	case userbalancelog.FieldBeforeAmount:
		m.ResetBeforeAmount()
		return nil
	case userbalancelog.FieldAfterAmount:
		m.ResetAfterAmount()
		return nil
	case userbalancelog.FieldReason:
		m.ResetReason()
		return nil
	case userbalancelog.FieldOperatorID:
		m.ResetOperatorID()
		return nil
	case userbalancelog.FieldOperatorName:
		m.ResetOperatorName()
		return nil
	case userbalancelog.FieldRelatedID:
		m.ResetRelatedID()
		return nil
	case userbalancelog.FieldRelatedType:
		m.ResetRelatedType()
		return nil
	case userbalancelog.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case userbalancelog.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	}
	return fmt.Errorf("unknown UserBalanceLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserBalanceLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, userbalancelog.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserBalanceLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userbalancelog.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserBalanceLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserBalanceLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserBalanceLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, userbalancelog.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserBalanceLogMutation) EdgeCleared(name string) bool {
	switch name {
	case userbalancelog.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserBalanceLogMutation) ClearEdge(name string) error {
	switch name {
	case userbalancelog.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserBalanceLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserBalanceLogMutation) ResetEdge(name string) error {
	switch name {
	case userbalancelog.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserBalanceLog edge %s", name)
}

// UserLoginLogMutation represents an operation that mutates the UserLoginLog nodes in the graph.
type UserLoginLogMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	ip_address    *string
	ip_country    *string
	ip_city       *string
	success       *bool
	device_info   *string
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*UserLoginLog, error)
	predicates    []predicate.UserLoginLog
}

var _ ent.Mutation = (*UserLoginLogMutation)(nil)

// userloginlogOption allows management of the mutation configuration using functional options.
type userloginlogOption func(*UserLoginLogMutation)

// newUserLoginLogMutation creates new mutation for the UserLoginLog entity.
func newUserLoginLogMutation(c config, op Op, opts ...userloginlogOption) *UserLoginLogMutation {
	m := &UserLoginLogMutation{
		config:        c,
		op:            op,
		typ:           TypeUserLoginLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserLoginLogID sets the ID field of the mutation.
func withUserLoginLogID(id int) userloginlogOption {
	return func(m *UserLoginLogMutation) {
		var (
			err   error
			once  sync.Once
			value *UserLoginLog
		)
		m.oldValue = func(ctx context.Context) (*UserLoginLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserLoginLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserLoginLog sets the old UserLoginLog of the mutation.
func withUserLoginLog(node *UserLoginLog) userloginlogOption {
	return func(m *UserLoginLogMutation) {
		m.oldValue = func(context.Context) (*UserLoginLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserLoginLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserLoginLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserLoginLog entities.
func (m *UserLoginLogMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserLoginLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserLoginLogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserLoginLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserLoginLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserLoginLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserLoginLog entity.
// If the UserLoginLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserLoginLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserLoginLogMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserLoginLogMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserLoginLog entity.
// If the UserLoginLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginLogMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserLoginLogMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *UserLoginLogMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserLoginLogMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserLoginLog entity.
// If the UserLoginLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginLogMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserLoginLogMutation) ResetUserID() {
	m.user = nil
}

// SetIPAddress sets the "ip_address" field.
func (m *UserLoginLogMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *UserLoginLogMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the UserLoginLog entity.
// If the UserLoginLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginLogMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *UserLoginLogMutation) ResetIPAddress() {
	m.ip_address = nil
}

// SetIPCountry sets the "ip_country" field.
func (m *UserLoginLogMutation) SetIPCountry(s string) {
	m.ip_country = &s
}

// IPCountry returns the value of the "ip_country" field in the mutation.
func (m *UserLoginLogMutation) IPCountry() (r string, exists bool) {
	v := m.ip_country
	if v == nil {
		return
	}
	return *v, true
}

// OldIPCountry returns the old "ip_country" field's value of the UserLoginLog entity.
// If the UserLoginLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginLogMutation) OldIPCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPCountry: %w", err)
	}
	return oldValue.IPCountry, nil
}

// ClearIPCountry clears the value of the "ip_country" field.
func (m *UserLoginLogMutation) ClearIPCountry() {
	m.ip_country = nil
	m.clearedFields[userloginlog.FieldIPCountry] = struct{}{}
}

// IPCountryCleared returns if the "ip_country" field was cleared in this mutation.
func (m *UserLoginLogMutation) IPCountryCleared() bool {
	_, ok := m.clearedFields[userloginlog.FieldIPCountry]
	return ok
}

// ResetIPCountry resets all changes to the "ip_country" field.
func (m *UserLoginLogMutation) ResetIPCountry() {
	m.ip_country = nil
	delete(m.clearedFields, userloginlog.FieldIPCountry)
}

// SetIPCity sets the "ip_city" field.
func (m *UserLoginLogMutation) SetIPCity(s string) {
	m.ip_city = &s
}

// IPCity returns the value of the "ip_city" field in the mutation.
func (m *UserLoginLogMutation) IPCity() (r string, exists bool) {
	v := m.ip_city
	if v == nil {
		return
	}
	return *v, true
}

// OldIPCity returns the old "ip_city" field's value of the UserLoginLog entity.
// If the UserLoginLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginLogMutation) OldIPCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPCity: %w", err)
	}
	return oldValue.IPCity, nil
}

// ClearIPCity clears the value of the "ip_city" field.
func (m *UserLoginLogMutation) ClearIPCity() {
	m.ip_city = nil
	m.clearedFields[userloginlog.FieldIPCity] = struct{}{}
}

// IPCityCleared returns if the "ip_city" field was cleared in this mutation.
func (m *UserLoginLogMutation) IPCityCleared() bool {
	_, ok := m.clearedFields[userloginlog.FieldIPCity]
	return ok
}

// ResetIPCity resets all changes to the "ip_city" field.
func (m *UserLoginLogMutation) ResetIPCity() {
	m.ip_city = nil
	delete(m.clearedFields, userloginlog.FieldIPCity)
}

// SetSuccess sets the "success" field.
func (m *UserLoginLogMutation) SetSuccess(b bool) {
	m.success = &b
}

// Success returns the value of the "success" field in the mutation.
func (m *UserLoginLogMutation) Success() (r bool, exists bool) {
	v := m.success
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccess returns the old "success" field's value of the UserLoginLog entity.
// If the UserLoginLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginLogMutation) OldSuccess(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccess: %w", err)
	}
	return oldValue.Success, nil
}

// ResetSuccess resets all changes to the "success" field.
func (m *UserLoginLogMutation) ResetSuccess() {
	m.success = nil
}

// SetDeviceInfo sets the "device_info" field.
func (m *UserLoginLogMutation) SetDeviceInfo(s string) {
	m.device_info = &s
}

// DeviceInfo returns the value of the "device_info" field in the mutation.
func (m *UserLoginLogMutation) DeviceInfo() (r string, exists bool) {
	v := m.device_info
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceInfo returns the old "device_info" field's value of the UserLoginLog entity.
// If the UserLoginLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginLogMutation) OldDeviceInfo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceInfo: %w", err)
	}
	return oldValue.DeviceInfo, nil
}

// ClearDeviceInfo clears the value of the "device_info" field.
func (m *UserLoginLogMutation) ClearDeviceInfo() {
	m.device_info = nil
	m.clearedFields[userloginlog.FieldDeviceInfo] = struct{}{}
}

// DeviceInfoCleared returns if the "device_info" field was cleared in this mutation.
func (m *UserLoginLogMutation) DeviceInfoCleared() bool {
	_, ok := m.clearedFields[userloginlog.FieldDeviceInfo]
	return ok
}

// ResetDeviceInfo resets all changes to the "device_info" field.
func (m *UserLoginLogMutation) ResetDeviceInfo() {
	m.device_info = nil
	delete(m.clearedFields, userloginlog.FieldDeviceInfo)
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserLoginLogMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userloginlog.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserLoginLogMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserLoginLogMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserLoginLogMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserLoginLogMutation builder.
func (m *UserLoginLogMutation) Where(ps ...predicate.UserLoginLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserLoginLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserLoginLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserLoginLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserLoginLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserLoginLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserLoginLog).
func (m *UserLoginLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserLoginLogMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, userloginlog.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userloginlog.FieldUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, userloginlog.FieldUserID)
	}
	if m.ip_address != nil {
		fields = append(fields, userloginlog.FieldIPAddress)
	}
	if m.ip_country != nil {
		fields = append(fields, userloginlog.FieldIPCountry)
	}
	if m.ip_city != nil {
		fields = append(fields, userloginlog.FieldIPCity)
	}
	if m.success != nil {
		fields = append(fields, userloginlog.FieldSuccess)
	}
	if m.device_info != nil {
		fields = append(fields, userloginlog.FieldDeviceInfo)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserLoginLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userloginlog.FieldCreatedAt:
		return m.CreatedAt()
	case userloginlog.FieldUpdatedAt:
		return m.UpdatedAt()
	case userloginlog.FieldUserID:
		return m.UserID()
	case userloginlog.FieldIPAddress:
		return m.IPAddress()
	case userloginlog.FieldIPCountry:
		return m.IPCountry()
	case userloginlog.FieldIPCity:
		return m.IPCity()
	case userloginlog.FieldSuccess:
		return m.Success()
	case userloginlog.FieldDeviceInfo:
		return m.DeviceInfo()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserLoginLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userloginlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userloginlog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userloginlog.FieldUserID:
		return m.OldUserID(ctx)
	case userloginlog.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case userloginlog.FieldIPCountry:
		return m.OldIPCountry(ctx)
	case userloginlog.FieldIPCity:
		return m.OldIPCity(ctx)
	case userloginlog.FieldSuccess:
		return m.OldSuccess(ctx)
	case userloginlog.FieldDeviceInfo:
		return m.OldDeviceInfo(ctx)
	}
	return nil, fmt.Errorf("unknown UserLoginLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserLoginLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userloginlog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userloginlog.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userloginlog.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userloginlog.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case userloginlog.FieldIPCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPCountry(v)
		return nil
	case userloginlog.FieldIPCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPCity(v)
		return nil
	case userloginlog.FieldSuccess:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccess(v)
		return nil
	case userloginlog.FieldDeviceInfo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceInfo(v)
		return nil
	}
	return fmt.Errorf("unknown UserLoginLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserLoginLogMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserLoginLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserLoginLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserLoginLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserLoginLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userloginlog.FieldIPCountry) {
		fields = append(fields, userloginlog.FieldIPCountry)
	}
	if m.FieldCleared(userloginlog.FieldIPCity) {
		fields = append(fields, userloginlog.FieldIPCity)
	}
	if m.FieldCleared(userloginlog.FieldDeviceInfo) {
		fields = append(fields, userloginlog.FieldDeviceInfo)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserLoginLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserLoginLogMutation) ClearField(name string) error {
	switch name {
	case userloginlog.FieldIPCountry:
		m.ClearIPCountry()
		return nil
	case userloginlog.FieldIPCity:
		m.ClearIPCity()
		return nil
	case userloginlog.FieldDeviceInfo:
		m.ClearDeviceInfo()
		return nil
	}
	return fmt.Errorf("unknown UserLoginLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserLoginLogMutation) ResetField(name string) error {
	switch name {
	case userloginlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userloginlog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userloginlog.FieldUserID:
		m.ResetUserID()
		return nil
	case userloginlog.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case userloginlog.FieldIPCountry:
		m.ResetIPCountry()
		return nil
	case userloginlog.FieldIPCity:
		m.ResetIPCity()
		return nil
	case userloginlog.FieldSuccess:
		m.ResetSuccess()
		return nil
	case userloginlog.FieldDeviceInfo:
		m.ResetDeviceInfo()
		return nil
	}
	return fmt.Errorf("unknown UserLoginLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserLoginLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, userloginlog.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserLoginLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userloginlog.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserLoginLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserLoginLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserLoginLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, userloginlog.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserLoginLogMutation) EdgeCleared(name string) bool {
	switch name {
	case userloginlog.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserLoginLogMutation) ClearEdge(name string) error {
	switch name {
	case userloginlog.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserLoginLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserLoginLogMutation) ResetEdge(name string) error {
	switch name {
	case userloginlog.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserLoginLog edge %s", name)
}
